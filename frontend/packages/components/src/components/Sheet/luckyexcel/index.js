import { customAlphabet as e, nanoid as t } from "nanoid";
import n from "papaparse";
import l from "dayjs";
import r from "@progress/jszip-esm";
import i from "@zwight/exceljs";
import { SheetTypes as s, VerticalAlign as a, WrapStrategy as o, TextDecoration as c, HorizontalAlign as u, ThemeColorType as h, BooleanNumber as f, PositionedObjectLayoutType as g, DrawingTypeEnum as d, CellValueType as m, LocaleType as p } from "@univerjs/core";
const E = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], b = { A: 0, B: 1, C: 2, D: 3, E: 4, F: 5, G: 6, H: 7, I: 8, J: 9, K: 10, L: 11, M: 12, N: 13, O: 14, P: 15, Q: 16, R: 17, S: 18, T: 19, U: 20, V: 21, W: 22, X: 23, Y: 24, Z: 25 }, T = "docProps/core.xml", y = "docProps/app.xml", v = "xl/workbook.xml", w = "xl/styles.xml"; let I = { 0: "General", 1: "0", 2: "0.00", 3: "#,##0", 4: "#,##0.00", 9: "0%", 10: "0.00%", 11: "0.00E+00", 12: "# ?/?", 13: "# ??/??", 14: "yyyy/m/d", 15: "d-mmm-yy", 16: "d-mmm", 17: "mmm-yy", 18: "h:mm AM/PM", 19: "h:mm:ss AM/PM", 20: "h:mm", 21: "h:mm:ss", 22: "yyyy/m/d h:mm", 37: "#,##0 ;(#,##0)", 38: "#,##0 ;[Red](#,##0)", 39: "#,##0.00;(#,##0.00)", 40: "#,##0.00;[Red](#,##0.00)", 45: "mm:ss", 46: "[h]:mm:ss", 47: "mmss.0", 48: "##0.0E+0", 49: "@" }; const R = { 0: "00000000", 1: "00FFFFFF", 2: "00FF0000", 3: "0000FF00", 4: "000000FF", 5: "00FFFF00", 6: "00FF00FF", 7: "0000FFFF", 8: "00000000", 9: "00FFFFFF", 10: "00FF0000", 11: "0000FF00", 12: "000000FF", 13: "00FFFF00", 14: "00FF00FF", 15: "0000FFFF", 16: "00800000", 17: "00008000", 18: "00000080", 19: "00808000", 20: "00800080", 21: "00008080", 22: "00C0C0C0", 23: "00808080", 24: "009999FF", 25: "00993366", 26: "00FFFFCC", 27: "00CCFFFF", 28: "00660066", 29: "00FF8080", 30: "000066CC", 31: "00CCCCFF", 32: "00000080", 33: "00FF00FF", 34: "00FFFF00", 35: "0000FFFF", 36: "00800080", 37: "00800000", 38: "00008080", 39: "000000FF", 40: "0000CCFF", 41: "00CCFFFF", 42: "00CCFFCC", 43: "00FFFF99", 44: "0099CCFF", 45: "00FF99CC", 46: "00CC99FF", 47: "00FFCC99", 48: "003366FF", 49: "0033CCCC", 50: "0099CC00", 51: "00FFCC00", 52: "00FF9900", 53: "00FF6600", 54: "00666699", 55: "00969696", 56: "00003366", 57: "00339966", 58: "00003300", 59: "00333300", 60: "00993300", 61: "00993366", 62: "00333399", 63: "00333333", 64: null, 65: null }, C = { none: 0, thin: 1, hair: 2, dotted: 3, dashed: 4, dashDot: 5, dashDotDot: 6, double: 7, medium: 8, mediumDashed: 9, mediumDashDot: 10, mediumDashDotDot: 11, slantDashDot: 12, thick: 13 }; let L = { "yyyy/m/d;@": "yyyy/MM/dd", "yyyy&quot;\u5e74&quot;m&quot;\u6708&quot;d&quot;\u65e5&quot;;@": "yyyy&quot;\u5e74&quot;MM&quot;\u6708&quot;dd&quot;\u65e5&quot;", "[$-409]yyyy/m/d\\ h:mm\\ AM/PM;@": "yyyy/MM/dd hh:mm AM/PM" }; const S = { 0: "defualt", 1: "Roman", 2: "Swiss", 3: "Modern", 4: "Script", 5: "Decorative" }, x = { list: "dropdown", whole: "number_integer", decimal: "number_decimal", custom: "text_content", textLength: "text_length", date: "date", unknown1: "number", unknown2: "checkbox", unknown3: "validity" }, N = ["number", "number_integer", "number_decimal", "text_length"], O = { common: { between: "bw", notBetween: "nb", equal: "eq", notEqualTo: "ne", moreThanThe: "gt", lessThan: "lt", greaterOrEqualTo: "gte", lessThanOrEqualTo: "lte" }, text_content: { include: "include", exclude: "exclude", equal: "equal" }, date: { between: "bw", notBetween: "nb", equal: "eq", notEqualTo: "ne", earlierThan: "bf", noEarlierThan: "nbf", laterThan: "af", noLaterThan: "naf" }, validity: { card: "card", phone: "phone" } }; var M, F, A; function P(e) { let t = e.split("!"), n = ""; if (t.length > 1 ? (t[0], n = t[1]) : n = t[0], -1 == n.indexOf(":")) { let e = parseInt(n.replace(/[^0-9]/g, "")) - 1, t = _(n.replace(/[^A-Za-z]/g, "")); return isNaN(e) || isNaN(t) ? null : { row: [e, e], column: [t, t] } } { let e = n.split(":"), t = [], l = []; return t[0] = parseInt(e[0].replace(/[^0-9]/g, "")) - 1, t[1] = parseInt(e[1].replace(/[^0-9]/g, "")) - 1, t[0] > t[1] ? null : (l[0] = _(e[0].replace(/[^A-Za-z]/g, "")), l[1] = _(e[1].replace(/[^A-Za-z]/g, "")), l[0] > l[1] ? null : { row: t, column: l }) } } function _(e) { let t = (e = e.toUpperCase()).length; if (0 == t) return NaN; let n = e.split(""), l = E.length, r = 0; for (let e = t - 1; e >= 0; e--)r += e == t - 1 ? b[n[e]] : Math.pow(l, t - e - 1) * (b[n[e]] + 1); return r } function k(e) { let t = E.length; if (e < t) return E[e]; { let n = 0, l = "", r = 1, i = 0; for (; e >= t / (t - 1) * (Math.pow(t, r++) - 1);)i = r; n = e - t / (t - 1) * (Math.pow(t, i - 1) - 1) + 1; for (let e = i; e > 0; e--) { let r = n; if (1 == e) return r %= t, 0 == r && (r = 26), l + E[r - 1]; r = Math.ceil(r / Math.pow(t, e - 1)), l += E[r - 1], e > 1 && (n -= (r - 1) * t) } } } function B(e) { return null == e ? 0 : e / 914400 * 72 / .75 } function D(e) { return .75 * e / 72 * 914400 } function X(e, t, n) { let l = e[t]; return l = null == l ? n : l, l } function G(e) { return Math.round(8 * (e - .83) + 5) } function H(e) { return Math.round(e / .75) } function V(e) { var t = e.toLowerCase(); if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(t)) { if (4 === t.length) { for (var n = "#", l = 1; l < 4; l += 1)n += t.slice(l, l + 1).concat(t.slice(l, l + 1)); t = n } var r = []; for (l = 1; l < 7; l += 2)r.push(parseInt("0x" + t.slice(l, l + 2))); return r } return null } function W(e) { null == e && (e = "Sheet"); let t = navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split(""), n = ""; for (let e = 0; e < 5; e++)n += t[Math.round(Math.random() * (t.length - 1))]; return e + "_" + n + "_" + (new Date).getTime() } function U(e) { return null == e || 0 == e.length ? e : e.replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#34;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&nbsp;/g, " ").replace(/&apos;/g, "'").replace(/&iexcl;/g, "\xa1").replace(/&cent;/g, "\xa2").replace(/&pound;/g, "\xa3").replace(/&curren;/g, "\xa4").replace(/&yen;/g, "\xa5").replace(/&brvbar;/g, "\xa6").replace(/&sect;/g, "\xa7").replace(/&uml;/g, "\xa8").replace(/&copy;/g, "\xa9").replace(/&ordf;/g, "\xaa").replace(/&laquo;/g, "\xab").replace(/&not;/g, "\xac").replace(/&shy;/g, "\xad").replace(/&reg;/g, "\xae").replace(/&macr;/g, "\xaf").replace(/&deg;/g, "\xb0").replace(/&plusmn;/g, "\xb1").replace(/&sup2;/g, "\xb2").replace(/&sup3;/g, "\xb3").replace(/&acute;/g, "\xb4").replace(/&micro;/g, "\xb5").replace(/&para;/g, "\xb6").replace(/&middot;/g, "\xb7").replace(/&cedil;/g, "\xb8").replace(/&sup1;/g, "\xb9").replace(/&ordm;/g, "\xba").replace(/&raquo;/g, "\xbb").replace(/&frac14;/g, "\xbc").replace(/&frac12;/g, "\xbd").replace(/&frac34;/g, "\xbe").replace(/&iquest;/g, "\xbf").replace(/&times;/g, "\xd7").replace(/&divide;/g, "\xf7").replace(/&Agrave;/g, "\xc0").replace(/&Aacute;/g, "\xc1").replace(/&Acirc;/g, "\xc2").replace(/&Atilde;/g, "\xc3").replace(/&Auml;/g, "\xc4").replace(/&Aring;/g, "\xc5").replace(/&AElig;/g, "\xc6").replace(/&Ccedil;/g, "\xc7").replace(/&Egrave;/g, "\xc8").replace(/&Eacute;/g, "\xc9").replace(/&Ecirc;/g, "\xca").replace(/&Euml;/g, "\xcb").replace(/&Igrave;/g, "\xcc").replace(/&Iacute;/g, "\xcd").replace(/&Icirc;/g, "\xce").replace(/&Iuml;/g, "\xcf").replace(/&ETH;/g, "\xd0").replace(/&Ntilde;/g, "\xd1").replace(/&Ograve;/g, "\xd2").replace(/&Oacute;/g, "\xd3").replace(/&Ocirc;/g, "\xd4").replace(/&Otilde;/g, "\xd5").replace(/&Ouml;/g, "\xd6").replace(/&Oslash;/g, "\xd8").replace(/&Ugrave;/g, "\xd9").replace(/&Uacute;/g, "\xda").replace(/&Ucirc;/g, "\xdb").replace(/&Uuml;/g, "\xdc").replace(/&Yacute;/g, "\xdd").replace(/&THORN;/g, "\xde").replace(/&szlig;/g, "\xdf").replace(/&agrave;/g, "\xe0").replace(/&aacute;/g, "\xe1").replace(/&acirc;/g, "\xe2").replace(/&atilde;/g, "\xe3").replace(/&auml;/g, "\xe4").replace(/&aring;/g, "\xe5").replace(/&aelig;/g, "\xe6").replace(/&ccedil;/g, "\xe7").replace(/&egrave;/g, "\xe8").replace(/&eacute;/g, "\xe9").replace(/&ecirc;/g, "\xea").replace(/&euml;/g, "\xeb").replace(/&igrave;/g, "\xec").replace(/&iacute;/g, "\xed").replace(/&icirc;/g, "\xee").replace(/&iuml;/g, "\xef").replace(/&eth;/g, "\xf0").replace(/&ntilde;/g, "\xf1").replace(/&ograve;/g, "\xf2").replace(/&oacute;/g, "\xf3").replace(/&ocirc;/g, "\xf4").replace(/&otilde;/g, "\xf5").replace(/&ouml;/g, "\xf6").replace(/&oslash;/g, "\xf8").replace(/&ugrave;/g, "\xf9").replace(/&uacute;/g, "\xfa").replace(/&ucirc;/g, "\xfb").replace(/&uuml;/g, "\xfc").replace(/&yacute;/g, "\xfd").replace(/&thorn;/g, "\xfe").replace(/&yuml;/g, "\xff") } !function (e) { e[e.Stack = 1073741824] = "Stack", e[e.PercentStack = 1610612736] = "PercentStack", e[e.Horizontal = 268435456] = "Horizontal" }(M || (M = {})), function (e) { e[e.None = 0] = "None", e[e.Line = 2] = "Line", e[e.Column = 4] = "Column", e[e.ColumnStacked = 1073741828] = "ColumnStacked", e[e.ColumnPercentStacked = 1610612740] = "ColumnPercentStacked", e[e.Bar = 268435460] = "Bar", e[e.BarStacked = 1342177284] = "BarStacked", e[e.BarPercentStacked = 1879048196] = "BarPercentStacked", e[e.Pie = 8] = "Pie", e[e.Doughnut = 264] = "Doughnut", e[e.Area = 16] = "Area", e[e.AreaStacked = 1073741840] = "AreaStacked", e[e.AreaPercentStacked = 1610612752] = "AreaPercentStacked", e[e.Radar = 32] = "Radar", e[e.Scatter = 64] = "Scatter", e[e.Combination = 128] = "Combination" }(F || (F = {})), function (e) { e[e.Empty = 0] = "Empty", e[e.CategoryName = 2] = "CategoryName", e[e.SeriesName = 4] = "SeriesName", e[e.Value = 8] = "Value", e[e.Percentage = 16] = "Percentage" }(A || (A = {})); class z { static trim(e) { return null == e && (e = ""), e.replace(/(^\s*)|(\s*$)/g, "") } static functionCopy(e, t, n) { let l = this; if (null == l.operatorjson) { let e = l.operator.split("|"), t = {}; for (let n = 0; n < e.length; n++)t[e[n].toString()] = 1; l.operatorjson = t } null == t && (t = "down"), null == n && (n = 1), "=" == e.substr(0, 1) && (e = e.substr(1)); let r = e.split(""), i = 0, s = "", a = "", o = { bracket: 0, comma: 0, squote: 0, dquote: 0 }; for (; i < r.length;) { let e = r[i]; if ("(" == e && 0 == o.dquote) o.bracket += 1, s.length > 0 ? a += s + "(" : a += "(", s = ""; else if (")" == e && 0 == o.dquote) o.bracket -= 1, a += l.functionCopy(s, t, n) + ")", s = ""; else if ('"' == e && 0 == o.squote) o.dquote > 0 ? (a += s + '"', o.dquote -= 1, s = "") : (o.dquote += 1, s += '"'); else if ("," == e && 0 == o.dquote) a += l.functionCopy(s, t, n) + ",", s = ""; else if ("&" == e && 0 == o.dquote) s.length > 0 ? (a += l.functionCopy(s, t, n) + "&", s = "") : a += "&"; else if (e in l.operatorjson && 0 == o.dquote) { let o = ""; i + 1 < r.length && (o = r[i + 1]); let c = i - 1, u = null; if (c >= 0) do { u = r[c--] } while (c >= 0 && " " == u); e + o in l.operatorjson ? (s.length > 0 ? (a += l.functionCopy(s, t, n) + e + o, s = "") : a += e + o, i++) : /[^0-9]/.test(o) || "-" != e || "(" != u && null != u && "," != u && " " != u && !(u in l.operatorjson) ? s.length > 0 ? (a += l.functionCopy(s, t, n) + e, s = "") : a += e : s += e } else s += e; i == r.length - 1 && (l.iscelldata(l.trim(s)) ? "down" == t ? a += l.downparam(l.trim(s), n) : "up" == t ? a += l.upparam(l.trim(s), n) : "left" == t ? a += l.leftparam(l.trim(s), n) : "right" == t && (a += l.rightparam(l.trim(s), n)) : a += l.trim(s)), i++ } return a } static downparam(e, t) { return this.updateparam("d", e, t) } static upparam(e, t) { return this.updateparam("u", e, t) } static leftparam(e, t) { return this.updateparam("l", e, t) } static rightparam(e, t) { return this.updateparam("r", e, t) } static updateparam(e, t, n) { let l, r = this, i = t.split("!"), s = ""; if (i.length > 1 ? (l = i[1], s = i[0] + "!") : l = i[0], -1 == l.indexOf(":")) { let i = parseInt(l.replace(/[^0-9]/g, "")), a = _(l.replace(/[^A-Za-z]/g, "")), o = K(l), c = o[0] ? "$" : "", u = o[1] ? "$" : ""; return "u" != e || o[0] ? "r" != e || o[1] ? "l" != e || o[1] ? o[0] || (i += n) : a -= n : a += n : i -= n, i < 0 || a < 0 ? r.error.r : isNaN(i) || isNaN(a) ? isNaN(i) ? isNaN(a) ? t : s + u + k(a) : s + c + i : s + u + k(a) + c + i } { l = l.split(":"); let i = [], a = []; if (i[0] = parseInt(l[0].replace(/[^0-9]/g, "")), i[1] = parseInt(l[1].replace(/[^0-9]/g, "")), i[0] > i[1]) return t; if (a[0] = _(l[0].replace(/[^A-Za-z]/g, "")), a[1] = _(l[1].replace(/[^A-Za-z]/g, "")), a[0] > a[1]) return t; let o = K(l[0]), c = K(l[1]), u = o[0] ? "$" : "", h = o[1] ? "$" : "", f = c[0] ? "$" : "", g = c[1] ? "$" : ""; return "u" == e ? (o[0] || (i[0] -= n), c[0] || (i[1] -= n)) : "r" == e ? (o[1] || (a[0] += n), c[1] || (a[1] += n)) : "l" == e ? (o[1] || (a[0] -= n), c[1] || (a[1] -= n)) : (o[0] || (i[0] += n), c[0] || (i[1] += n)), i[0] < 0 || a[0] < 0 ? r.error.r : isNaN(a[0]) && isNaN(a[1]) ? s + u + i[0] + ":" + f + i[1] : isNaN(i[0]) && isNaN(i[1]) ? s + h + k(a[0]) + ":" + g + k(a[1]) : s + h + k(a[0]) + u + i[0] + ":" + g + k(a[1]) + f + i[1] } } static iscelldata(e) { let t, n = e.split("!"); t = n.length > 1 ? n[1] : n[0]; let l = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g, r = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g; if (-1 == t.indexOf(":")) { let e = parseInt(t.replace(/[^0-9]/g, "")) - 1, n = _(t.replace(/[^A-Za-z]/g, "")); return !(isNaN(e) || isNaN(n) || !t.toString().match(l)) || !!isNaN(e) && (isNaN(n), !1) } { r = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g, t = t.split(":"); let e = [], n = []; return e[0] = parseInt(t[0].replace(/[^0-9]/g, "")) - 1, e[1] = parseInt(t[1].replace(/[^0-9]/g, "")) - 1, !(e[0] > e[1] || (n[0] = _(t[0].replace(/[^A-Za-z]/g, "")), n[1] = _(t[1].replace(/[^A-Za-z]/g, "")), n[0] > n[1] || !t[0].toString().match(r) || !t[1].toString().match(r))) } } } function q(e) { return !/[^\u0800-\u4e00]/.test(e) } function j(e) { if (!e || e?.length <= 0) return []; let t = (l = (e = e.toUpperCase()).split(" ").filter((e => e && e.trim())), l?.map((e => { if (e.includes(":")) { let t = e.split(":"); 2 === t?.length && (l = l.concat(function (e) { let t = []; const n = new RegExp(/[A-Z]+|[0-9]+/g), l = e[0]?.match(n), r = e[1]?.match(n), i = Math.max(_(l[0]), _(r[0])), s = Math.min(_(l[0]), _(r[0])), a = Math.max(parseInt(l[1]), parseInt(r[1])), o = Math.min(parseInt(l[1]), parseInt(r[1])); for (let e = s; e <= i; e++)for (let n = o; n <= a; n++)t.push(`${k(e)}${n}`); return t }(t))).splice(l.indexOf(e), 1) } })), l.filter(((e, t, n) => n.indexOf(e) === t))), n = []; var l; for (let e = 0; e < t.length; e++) { let l = Y(t[e]); l && n.push(l) } return n } function Y(e) { let t = e.match(/[A-Z]+|[0-9]+/g), n = t.length, l = new RegExp("^[A-Z]+$"), r = ""; for (let e = n - 1; e >= 0; e--) { let n = t[e]; l.test(n) ? r += _(n) + "_" : r += parseInt(n) - 1 + "_" } return r.substring(0, r.length - 1) } function $(e) { if (!e && e?.length <= 0) return ""; const t = e.length, n = e.lastIndexOf("!"), l = [e.slice(0, n), e.slice(n + 1, t)], r = l[1] || "", i = r.indexOf("R"), s = r.indexOf("C"), a = Number(r.slice(i + 1, s)), o = k(Number(r.slice(s + 1, r?.length)) - 1); return `${l[0]}!${o}${a}` } function Z(e) { if (!e || e?.length <= 0) return {}; const t = new RegExp("</x14:formula[^]>", "g"), n = e.match(t)?.length, l = `</x14:formula${n}>`, r = e.indexOf(l); let i = e.substring(0, r + l.length); i = i.replace(/<xm:f>/g, "").replace(/<\/xm:f>/g, "").replace(/x14:/g, "").replace(/\/x14:/g, ""); const s = i, a = e.indexOf("<xm:sqref>"), o = e.indexOf("</xm:sqref>"); return { formula: s, sqref: e.substring(a + 10, o) } } function J(e) { if (!e || e?.length <= 0) return []; const t = new RegExp("formula", "g"), n = (e.match(t)?.length || 0) / 2; if (0 === n) return []; let l = []; for (let t = 1; t <= n; t++) { const n = `<formula${t}>`?.length, r = e.indexOf(`<formula${t}>`), i = e.indexOf(`</formula${t}>`), s = e.substring(r + n, i); l.push(U(s.replace(/&quot;|^\"|\"$/g, ""))) } return l } function K(e) { let t = e.replace(/[^0-9]/g, ""), n = e.replace(/[^A-Za-z]/g, ""), l = e.substr(e.indexOf(t) - 1, 1), r = e.substr(e.indexOf(n) - 1, 1), i = [!1, !1]; return "$" == l && (i[0] = !0), "$" == r && (i[1] = !0), i } function Q(e) { if (null == e || 0 === e.length) return Number.NaN; const t = e.toLowerCase().split(""), n = t.length; let l = 0, r = 0; for (let e = 0; e < n; e++)r = t[e].charCodeAt(0) - 96, l += r * 26 ** (n - e - 1); return 0 === l ? Number.NaN : l - 1 } z.operator = "==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^", z.error = { v: "#VALUE!", n: "#NAME?", na: "#N/A", r: "#REF!", d: "#DIV/0!", nm: "#NUM!", nl: "#NULL!", sp: "#SPILL!" }, z.operatorjson = null; const ee = "A".charCodeAt(0), te = "Z".charCodeAt(0); function ne(e) { const t = te - ee + 1; let n = ""; for (; e >= 0;)n = String.fromCharCode(e % t + ee) + n, e = Math.floor(e / t) - 1; return n } function le(e) { if (null == e) return e; try { return Number.isNaN(Number(e)) ? e : Number(e) } catch (t) { return e } } function re(n = 21, l) { return l ? e(l, n)() : t(n) } function ie(e) { if (!e) return {}; try { return JSON.parse(e) } catch (e) { return null } } function se(e) { return "[object Object]" === Object.prototype.toString.call(e) } function ae(e) { for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? delete e[t] : se(e[t]) && null !== e[t] && ae(e[t])); return e } function oe(e) { return null == e } class ce { getElementsByOneTag(e, t) { let n; if (e.indexOf("|") > -1) { let t = e.split("|"), l = ""; for (let e = 0; e < t.length; e++) { let n = t[e]; l += "|<" + n + " [^>]+?[^/]>[\\s\\S]*?</" + n + ">|<" + n + " [^>]+?/>|<" + n + ">[\\s\\S]*?</" + n + ">|<" + n + "/>" } l = l.substr(1, l.length), n = new RegExp(l, "g") } else n = new RegExp("<" + e + " [^>]+?[^/]>[\\s\\S]*?</" + e + ">|<" + e + " [^>]+?/>|<" + e + ">[\\s\\S]*?</" + e + ">|<" + e + "/>", "g"); let l = t.match(n); return null == l ? [] : l } getElementByTagLink(e, t) { const n = (new DOMParser).parseFromString(t, "text/xml"); let l = Array.from(n.children); if (e.indexOf("/") > -1) { let t = e.split("/"); for (let e = 0; e < t.length; e++) { const n = t[e], r = l.findIndex((e => Array.from(e.children).findIndex((e => e.tagName === n)) > -1)); if (-1 === r && e <= t.length - 1) return []; l = Array.from(l[r].children).filter((e => e.tagName === n)) } } else l = Array.from(l[0].children).filter((t => t.tagName === e)); const r = new XMLSerializer; return l.map((e => r.serializeToString(e))) } } class ue extends ce { constructor(e) { super(), this.originFile = e } getElementsByTagName(e, t, n = !0) { let l = this.getFileByName(t); n || (l = t); let r, i = e.split("/"); for (let e in i) { let t = i[e]; if (null == r) r = this.getElementsByOneTag(t, l); else if (r instanceof Array) { let e = []; for (let n in r) { let l = r[n]; e = e.concat(this.getElementsByOneTag(t, l)) } r = e } else r = this.getElementsByOneTag(t, r) } let s = []; for (let e = 0; e < r.length; e++) { let t = new he(r[e]); s.push(t) } return s } getElementsByTagNameLink(e, t, n = !0) { let l = this.getFileByName(t); n || (l = t); const r = this.getElementByTagLink(e, l); let i = []; for (let e = 0; e < r.length; e++) { let t = new he(r[e]); i.push(t) } return i } getFileByName(e) { for (let t in this.originFile) if (t.indexOf(e) > -1) return this.originFile[t]; return "" } } class he extends ce { constructor(e) { super(), this.elementString = e, this.setValue(); const t = new RegExp('[a-zA-Z0-9_:]*?=".*?"', "g"); let n = this.container.match(t); if (this.attributeList = {}, null != n) for (let e in n) { let t = n[e]; if (0 == t.length) continue; let l = t.substr(0, t.indexOf("=")), r = t.substr(t.indexOf("=") + 1); null != l && null != r && 0 != l.length && 0 != r.length && (this.attributeList[l] = r.substr(1, r.length - 2)) } } get(e) { return this.attributeList[e] } getInnerElements(e) { let t = this.getElementsByOneTag(e, this.elementString), n = []; for (let e = 0; e < t.length; e++) { let l = new he(t[e]); n.push(l) } return 0 == n.length ? null : n } getInnerElementsTagLink(e) { const t = this.getElementByTagLink(e, this.elementString); let n = []; for (let e = 0; e < t.length; e++) { let l = new he(t[e]); n.push(l) } return 0 == n.length ? null : n } setValue() { let e = this.elementString; if ("/>" == e.substr(e.length - 2, 2)) this.value = "", this.container = e; else { let t = this.getFirstTag(), n = new RegExp("(<" + t + " [^>]+?[^/]>)([\\s\\S]*?)</" + t + ">|(<" + t + ">)([\\s\\S]*?)</" + t + ">", "g").exec(e); null != n && (null != n[1] ? (this.container = n[1], this.value = n[2]) : (this.container = n[3], this.value = n[4])) } } getFirstTag() { let e = this.elementString, t = e.substr(0, e.indexOf(" ")); return ("" == t || t.indexOf(">") > -1) && (t = e.substr(0, e.indexOf(">"))), t = t.substr(1, t.length), t } } function fe(e, t, n = "g") { let l = e.attributeList, r = t.clrScheme, i = t.indexedColors; t.mruColors; let s, a = function (e, t) { let n = {}; if (null == e || 0 == e.length) return t; for (let l in t) { let r = t[l], i = e[parseInt(l)]; if (null == i) n[l] = r; else { let e = i.attributeList.rgb; n[l] = e } } return n }(i, R), o = l.indexed, c = l.rgb, u = l.theme, h = l.tint; if (null != o) s = a[parseInt(o)], null != s && (s = s.substring(s.length - 6, s.length), s = "#" + s); else if (null != c) c = c.substring(c.length - 6, c.length), s = "#" + c; else if (null != u) { let e = parseInt(u); 0 == e ? e = 1 : 1 == e ? e = 0 : 2 == e ? e = 3 : 3 == e && (e = 2); let t = r[e]; if (null != t) { let e = t.getInnerElements("a:sysClr|a:srgbClr"); if (null != e) { let t = e[0], n = t.attributeList; t.container.indexOf("sysClr") > -1 ? null != n.lastClr ? s = "#" + n.lastClr : null != n.val && (s = "#" + n.val) : t.container.indexOf("srgbClr") > -1 && (s = "#" + n.val) } } } if (null != h) { let e = parseFloat(h); null != s && (s = function (e, t) { let n = e.substring(e.length - 6, e.length), l = V("#" + n), r = function (e, t, n) { e /= 255, t /= 255, n /= 255; var l, r, i = Math.max(e, t, n), s = Math.min(e, t, n), a = (i + s) / 2; if (i == s) l = r = 0; else { var o = i - s; switch (r = a > .5 ? o / (2 - i - s) : o / (i + s), i) { case e: l = (t - n) / o + (t < n ? 6 : 0); break; case t: l = (n - e) / o + 2; break; case n: l = (e - t) / o + 4 }l /= 6 } return [l, r, a] }(l[0], l[1], l[2]); if (t > 0) r[2] = r[2] * (1 - t) + t; else { if (!(t < 0)) return "#" + n; r[2] = r[2] * (1 + t) } return function (e) { if (/^(rgb|RGB)/.test(e)) { for (var t = e.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(","), n = "#", l = 0; l < t.length; l++) { var r = Number(t[l]).toString(16); r.length < 2 && (r = "0" + r), n += r } return 7 !== n.length && (n = e), n } if (/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(e)) { var i = e.replace(/#/, "").split(""); if (6 === i.length) return e; if (3 === i.length) { var s = "#"; for (l = 0; l < i.length; l += 1)s += i[l] + i[l]; return s } } return e }("RGB(" + function (e, t, n) { var l, r, i; if (0 == t) l = r = i = n; else { var s = function (e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e }, a = n < .5 ? n * (1 + t) : n + t - n * t, o = 2 * n - a; l = s(o, a, e + 1 / 3), r = s(o, a, e), i = s(o, a, e - 1 / 3) } return [Math.round(255 * l), Math.round(255 * r), Math.round(255 * i)] }(r[0], r[1], r[2]).join(",") + ")") }(s, e)) } return s } function ge(e, t) { let n, l = e.getInnerElements(t); if (null != l && l.length > 0) if ("b" == t || "i" == t || "strike" == t) n = "1"; else if ("u" == t) { let e = l[0].attributeList.val; n = "double" == e ? "2" : "singleAccounting" == e ? "3" : "doubleAccounting" == e ? "4" : "1" } else if ("vertAlign" == t) { let e = l[0].attributeList.val; "subscript" == e ? n = "1" : "superscript" == e && (n = "2") } else n = l[0].attributeList.val; return n } class de { } class me { } class pe { } class Ee { } class be { } class Te { } class ye { } class ve { } class we { } class Ie { } class Re { } class Ce { } class Le { } class Se { } class xe { } class Ne { } class Oe { } var Me; function Fe(e, t) { if (null == e) return null; let n = e[0], l = n.attributeList.style; if (null == l || "none" == l) return null; let r = n.getInnerElements("color"), i = "#000000"; null != r && (i = fe(r[0], t, "b"), null == i && (i = "#000000")); let s = new Ce; return s.style = C[l], s.color = i, s } function Ae(e, t) { const n = new Re; let l = !1; if (!e) return { borderCellValue: n, isAdd: l }; let r = e.getInnerElements("left"), i = e.getInnerElements("right"), s = e.getInnerElements("top"), a = e.getInnerElements("bottom"), o = e.getInnerElements("diagonal"), c = e.getInnerElements("start"), u = e.getInnerElements("end"), h = Fe(r, t), f = Fe(i, t), g = Fe(s, t), d = Fe(a, t), m = Fe(o, t), p = Fe(c, t), E = Fe(u, t); if (null != p && null != p.color && (n.l = p, l = !0), null != E && null != E.color && (n.r = E, l = !0), null != h && null != h.color && (n.l = h, l = !0), null != f && null != f.color && (n.r = f, l = !0), null != g && null != g.color && (n.t = g, l = !0), null != d && null != d.color && (n.b = d, l = !0), null != m && null != m.color) { const t = e.attributeList.diagonalUp, r = e.attributeList.diagonalDown; "1" === t && (n.bl_tr = m), "1" === r && (n.tl_br = m), l = !0 } return { borderCellValue: n, isAdd: l } } function Pe(e, t) { let n = e.getInnerElements("patternFill"); if (null != n) { let e, l, r = n[0], i = r.getInnerElements("fgColor"), s = r.getInnerElements("bgColor"); if (null != i && (e = fe(i[0], t)), null != s && (l = fe(s[0], t)), null != e) return e; if (null != l) return l } else if (null != e.getInnerElements("gradientFill")) return null } function _e(e, t) { let n = null; const l = new Te; let r = e.getInnerElements("sz"), i = e.getInnerElements("color"), s = e.getInnerElements("name"), a = e.getInnerElements("family"); e.getInnerElements("charset"); let o = e.getInnerElements("b"), c = e.getInnerElements("i"), u = e.getInnerElements("strike"), h = e.getInnerElements("u"); if (null != r && r.length > 0) { let e = r[0].attributeList.val; null != e && (l.fs = parseInt(e)) } if (null != i && i.length > 0) { let e = fe(i[0], t, "t"); null != e && (l.fc = e) } if (null != a && a.length > 0) { let e = a[0].attributeList.val; null != e && (n = S[e]) } if (null != s && s.length > 0) { let e = s[0].attributeList.val; null != e && (l.ff = e) } if (null != o && o.length > 0) { let e = o[0].attributeList.val; l.bl = "0" == e ? 0 : 1 } if (null != c && c.length > 0) { let e = c[0].attributeList.val; l.it = "0" == e ? 0 : 1 } if (null != u && u.length > 0) { let e = u[0].attributeList.val; l.cl = "0" == e ? 0 : 1 } if (null != h && h.length > 0) { let e = h[0].attributeList.val; l.un = "single" == e ? 1 : "double" == e ? 2 : "singleAccounting" == e ? 3 : "doubleAccounting" == e ? 4 : 0 } return { cellValue: l, familyFont: n } } !function (e) { e[e.NONE = 0] = "NONE", e[e.ROW = 1] = "ROW", e[e.COLUMN = 2] = "COLUMN", e[e.ALL = 3] = "ALL" }(Me || (Me = {})); const ke = e => e.split(" ").map((e => { const t = e.split(":"), n = parseInt(t[0].replace(/[^0-9]/g, "")) - 1, l = Q(t[0].replace(/[^A-Za-z]/g, "")), r = K(t[0]), i = 1 === t.length ? n : parseInt(t[1].replace(/[^0-9]/g, "")) - 1, s = 1 === t.length ? l : Q(t[1].replace(/[^A-Za-z]/g, "")), a = 1 === t.length ? r : K(t[1]), o = e => !0 === e[0] && !0 === e[1] ? Me.ALL : !0 === e[0] ? Me.ROW : !0 === e[1] ? Me.COLUMN : Me.NONE; return { startRow: n, startColumn: l, endRow: i, endColumn: s, startAbsoluteRefType: o(r), endAbsoluteRefType: o(a), rangeType: 0 } })); var Be; !function (e) { e.UTF8 = "UTF-8", e.GBK = "GBK", e.CP936 = "CP936", e.ISO8859 = "ISO-8859" }(Be || (Be = {})); const De = e => e.replace(/_x000D_/g, "").replace(/&#13;&#10;/g, "\r\n").replace(/&#13;/g, "\r").replace(/&#10;/g, "\n"); class Xe extends be { constructor(e, t, n, l, r, i, s, a, o) { super(), this.cell = e, this.sheetFile = i, this.styles = n, this.sharedStrings = l, this.readXml = o, this.mergeCells = r, this.cellImages = s, this.imageList = a, this.cellSize = t; let c = e.attributeList, u = c.r, h = c.s, f = c.t, g = P(u); this.r = g.row[0], this.c = g.column[0], this.v = this.generateValue(h, f) } generateValue(e, t) { let n = this.cell.getInnerElements("v"), l = this.cell.getInnerElements("f"); null == n && (n = this.cell.getInnerElements("t")); let r = this.styles.cellXfs, i = this.styles.cellStyleXfs; this.styles.cellStyles; let s = this.styles.fonts, a = this.styles.fills, o = this.styles.borders, c = this.styles.numfmts; this.styles.clrScheme; let u = this.sharedStrings, h = new Te; if (null != l) { let e = l[0].attributeList, t = e.t, n = e.ref, r = e.si, i = l[0].value; "shared" == t && (this._fomulaRef = n, this._formulaType = t, this._formulaSi = r), (null != n || null != i && i.length > 0) && (i = U(i), h.f = "=" === i[0] ? i : "=" + i) } let f, g = null; if (null != e) { let n, l, u, d, m, p, E, b, T, y = r[parseInt(e)], v = y.attributeList.xfId; if (null != v) { let e = i[parseInt(v)], t = e.attributeList, r = t.applyNumberFormat, s = t.applyFont, a = t.applyFill, o = t.applyBorder, c = t.applyAlignment; if (t.applyProtection, f = t.quotePrefix, "0" != r && null != t.numFmtId && (n = t.numFmtId), "0" != s && null != t.fontId && (l = t.fontId), "0" != a && null != t.fillId && (u = t.fillId), "0" != o && null != t.borderId && (d = t.borderId), null != c && "0" != c) { let t = e.getInnerElements("alignment"); if (null != t) { let e = t[0].attributeList; null != e.horizontal && (m = e.horizontal), null != e.vertical && (p = e.vertical), null != e.wrapText && (E = e.wrapText), null != e.textRotation && (b = e.textRotation), null != e.shrinkToFit && e.shrinkToFit, null != e.indent && (T = e.indent) } } } let w = y.attributeList.applyNumberFormat, I = y.attributeList.applyFont, R = y.attributeList.applyFill, C = y.attributeList.applyBorder, L = y.attributeList.applyAlignment; if (null != y.attributeList.applyProtection && y.attributeList.applyProtection, null != y.attributeList.quotePrefix && (f = y.attributeList.quotePrefix), "0" != w && null != y.attributeList.numFmtId && (n = y.attributeList.numFmtId), "0" != I && (l = y.attributeList.fontId), "0" != R && (u = y.attributeList.fillId), "0" != C && (d = y.attributeList.borderId), "0" != L) { let e = y.getInnerElements("alignment"); if (null != e && e.length > 0) { let t = e[0].attributeList; null != t.horizontal && (m = t.horizontal), null != t.vertical && (p = t.vertical), null != t.wrapText && (E = t.wrapText), null != t.textRotation && (b = t.textRotation), null != t.shrinkToFit && t.shrinkToFit, null != t.indent && (T = t.indent) } } if (null != n) { let e = c[parseInt(n)], l = new ye; l.fa = U(e), l.t = t || "d", h.ct = l } if (null != u) { let e = Pe(a[parseInt(u)], this.styles); null != e && (h.bg = e) } if (null != l) { let e = s[parseInt(l)]; if (null != e) { const { cellValue: t, familyFont: n } = _e(e, this.styles); h = { ...h, ...t }, g = n } } if (null != m && (h.ht = "center" == m || "centerContinuous" == m ? 0 : "left" == m ? 1 : "right" == m ? 2 : "distributed" == m ? 0 : "fill" == m || "general" == m ? 1 : "justify" == m ? 0 : 1), h.vt = null != p ? "bottom" == p ? 2 : "center" == p || "distributed" == p || "justify" == p ? 0 : 1 : 2, h.tb = null != E && "1" == E ? 2 : 1, null != b && ("255" == b ? h.tr = 3 : (h.tr = 0, h.rt = parseInt(b))), null != T) { const e = parseInt(T); isNaN(e) || (h.ti = e) } if (null != d) { let e = o[parseInt(d)], t = new Ie; t.rangeType = "cell"; const { isAdd: n, borderCellValue: l } = Ae(e, this.styles); l.row_index = this.r, l.col_index = this.c, n && (t.value = l, this._borderObject = t) } } else h.tb = 1; if (null != n) { let e = n[0].value; /&#\d+;/.test(e) && (e = this.htmlDecode(e)); const l = e => { let t = e.getInnerElements("r"); if (null == t) { let t = e.getInnerElements("t"); if (null != t) { let e = ""; if (t.forEach((t => { e += t.value })), e = U(e), /&#\d+;/.test(e) && (e = this.htmlDecode(e)), "Roman" == g && e.length > 0) { let t = e.split(""), r = null, i = "", s = null, a = "Times New Roman"; null != h.ff && (a = h.ff); let o = h.ct; null == o && (o = new ye), null == o.s && (o.s = []); for (let e = 0; e < t.length; e++) { let c = t[e], u = null, f = a; if (/[\u3002|\uff1f|\uff01|\uff0c|\u3001|\uff1b|\uff1a|\u201c|\u201d|\u2018|\u2019|\uff08|\uff09|\u300a|\u300b|\u3008|\u3009|\u3010|\u3011|\u300e|\u300f|\u300c|\u300d|\ufe43|\ufe44|\u3014|\u3015|\u2026|\u2014|\uff5e|\ufe4f|\uffe5]/.test(l = c) || !/[^\u4e00-\u9fa5]/.test(l) ? (u = "c", f = "\u5b8b\u4f53") : q(c) ? (u = "j", f = "Yu Gothic") : (n = c) > 12592 && n < 12687 || n >= 44032 && n <= 55203 ? (u = "k", f = "Malgun Gothic") : u = "e", u != r && null != r || e == t.length - 1) { let n = new ve; if (n.ff = s, null != h.fc && (n.fc = h.fc), null != h.fs && (n.fs = h.fs), null != h.cl && (n.cl = h.cl), null != h.un && (n.un = h.un), null != h.bl && (n.bl = h.bl), null != h.it && (n.it = h.it), e == t.length - 1) { if (u != r) { n.ff = s, n.v = i, o.s.push(n); let e = new ve; e.ff = f, e.v = c, null != h.fc && (e.fc = h.fc), null != h.fs && (e.fs = h.fs), null != h.cl && (e.cl = h.cl), null != h.un && (e.un = h.un), null != h.bl && (e.bl = h.bl), null != h.it && (e.it = h.it), o.s.push(e); break } n.ff = f, n.v = i + c } else n.v = i; o.s.push(n), i = c } else i += c; r = u, s = f } o.t = "inlineStr", h.ct = o } else if (e = De(e), e.indexOf("\r\n") > -1 || e.indexOf("\n") > -1) { let t = new ve; t.v = e; let n = h.ct; null == n && (n = new ye), null != h.ff && (t.ff = h.ff), null != h.fc && (t.fc = h.fc), null != h.fs && (t.fs = h.fs), null != h.cl && (t.cl = h.cl), null != h.un && (t.un = h.un), null != h.bl && (t.bl = h.bl), null != h.it && (t.it = h.it), n.t = "inlineStr", n.s = [t], h.ct = n } else h.v = e, f = "1" } } else { let e = []; t.forEach((t => { let n = t.getInnerElements("t"), l = t.getInnerElements("rPr"), r = new ve; if (null != n && n.length > 0) { let e = n[0].value; e = De(e), e = U(e), r.v = e } if (null != l && l.length > 0) { let e = l[0], t = ge(e, "sz"), n = ge(e, "rFont"); ge(e, "family"), ge(e, "charset"), ge(e, "scheme"); let i, s, a = ge(e, "b"), o = ge(e, "i"), c = ge(e, "u"), u = ge(e, "strike"), f = ge(e, "vertAlign"), g = e.getInnerElements("color"); null != g && g.length > 0 && (i = fe(g[0], this.styles, "t")), null != n && (s = n), null != s ? r.ff = s : null != h.ff && (r.ff = h.ff), null != i && (r.fc = i), null != t ? r.fs = parseInt(t) : null != h.fs && (r.fs = h.fs), null != u ? r.cl = parseInt(u) : null != h.cl && (r.cl = h.cl), null != c ? r.un = parseInt(c) : null != h.un && (r.un = h.un), null != a ? r.bl = parseInt(a) : null != h.bl && (r.bl = h.bl), null != o ? r.it = parseInt(o) : null != h.it && (r.it = h.it), null != f && (r.va = parseInt(f)) } else null == r.ff && null != h.ff && (r.ff = h.ff), null == r.fc && null != h.fc && (r.fc = h.fc), null == r.fs && null != h.fs && (r.fs = h.fs), null == r.cl && null != h.cl && (r.cl = h.cl), null == r.un && null != h.un && (r.un = h.un), null == r.bl && null != h.bl && (r.bl = h.bl), null == r.it && null != h.it && (r.it = h.it); e.push(r) })); let n = h.ct; null == n && (n = new ye), n.t = "inlineStr", n.s = e, h.ct = n } var n, l }; if ("s" == t) l(u[parseInt(n[0].value)]); else if ("inlineStr" == t && null != n) { h.v = this.htmlDecode(e); let t = h.ct; null == t && (t = new ye), t.t = "s", h.ct = t; let n = this.cell.getInnerElements("is"); n.length && l(n[0]) } else if ("str" == t && e.includes("=DISPIMG")) { let t = h.ct; null == t && (t = new ye), t.t = "str", t.ci = this.getCellImage(h, e), h.ct = t } else e = U(e), h.v = e } if (null != f && (h.qp = parseInt(f)), null !== t && !h.ct?.t) { let e = new ye; e.t = t || "d", h.ct = e } return h } htmlDecode(e) { return e.replace(/&#(x)?([^&]{1,5});/g, (function (e, t, n) { return String.fromCharCode(parseInt(n, t ? 16 : 10)) })) } getCellImage(e, t) { const n = this.extractImageId(t); let l = {}; return this.cellImages.forEach((e => { const t = e.getInnerElements("xdr:pic")[0], r = t.getInnerElements("xdr:nvPicPr")[0].getInnerElements("xdr:cNvPr")[0], i = t.getInnerElements("xdr:blipFill")[0].getInnerElements("a:blip")[0], s = r.get("name"), a = i.get("r:embed"); if (n == s) { const e = this.getBase64ByRid(a, "xl/_rels/cellimages.xml.rels"); l = e; let n = 0, i = 0, s = 0, o = 0; const c = t.getInnerElements("xdr:spPr")[0].getInnerElements("a:xfrm")[0], u = c.getInnerElements("a:off")[0], h = c.getInnerElements("a:ext")[0]; s = B(parseInt(h.get("cx"))), o = B(parseInt(h.get("cy"))), n = B(parseInt(u.get("x"))), i = B(parseInt(u.get("y"))); const f = s / this.cellSize.width, g = o / this.cellSize.height; f > 1 && f > g && (o /= f, s = this.cellSize.width), g > 1 && g > f && (s /= g, o = this.cellSize.height); let d = { height: o, left: n, top: i, width: s }; l.default = d, l.descr = r.get("descr") } })), l } extractImageId(e) { const t = e.match(/ID_[A-Za-z0-9]{32}/); return t ? t[0] : null } getBase64ByRid(e, t) { let n = this.readXml.getElementsByTagName("Relationships/Relationship", t); if (null != n && n.length > 0) for (let t = 0; t < n.length; t++) { let l = n[t].attributeList, r = X(l, "Id", null), i = X(l, "Target", null); if (r == e) return i = i.replace(/\.\.\//g, ""), i = "xl/" + i, this.imageList.getImageByName(i) } return {} } } var Ge, He, Ve, We, Ue; !function (e) { e.beginsWith = "beginsWith", e.endsWith = "endsWith", e.containsText = "containsText", e.notContainsText = "notContainsText", e.equal = "equal", e.notEqual = "notEqual", e.containsBlanks = "containsBlanks", e.notContainsBlanks = "notContainsBlanks", e.containsErrors = "containsErrors", e.notContainsErrors = "notContainsErrors" }(Ge || (Ge = {})), function (e) { e.today = "today", e.yesterday = "yesterday", e.tomorrow = "tomorrow", e.last7Days = "last7Days", e.thisMonth = "thisMonth", e.lastMonth = "lastMonth", e.nextMonth = "nextMonth", e.thisWeek = "thisWeek", e.lastWeek = "lastWeek", e.nextWeek = "nextWeek" }(He || (He = {})), function (e) { e.greaterThan = "greaterThan", e.greaterThanOrEqual = "greaterThanOrEqual", e.lessThan = "lessThan", e.lessThanOrEqual = "lessThanOrEqual", e.notBetween = "notBetween", e.between = "between", e.equal = "equal", e.notEqual = "notEqual" }(Ve || (Ve = {})), function (e) { e.highlightCell = "highlightCell", e.dataBar = "dataBar", e.colorScale = "colorScale", e.iconSet = "iconSet" }(We || (We = {})), function (e) { e.uniqueValues = "uniqueValues", e.duplicateValues = "duplicateValues", e.rank = "rank", e.text = "text", e.timePeriod = "timePeriod", e.number = "number", e.average = "average", e.formula = "formula" }(Ue || (Ue = {})); class ze { constructor(e, t, n) { this.stopIfTrue = !1, this.handleRules = (e, t, n) => { const { attributeList: l, value: r, extLst: i, isExtLst: s } = e, a = X(l, "type", "expression"), o = { type: We.highlightCell }, c = X(l, "operator", ""), u = X(l, "rank", ""), h = t.getElementsByTagName("formula", r, !1); switch (X(l, "aboveAverage", ""), c && (o.operator = c), (h[0]?.value || "0" == h[0]?.value) && (o.value = le(h[0]?.value)), a) { case "expression": o.subType = Ue.formula; break; case "cellIs": o.subType = Ue.number; break; case "top10": o.subType = Ue.rank; const e = X(l, "percent", "0"), a = X(l, "bottom", "0"); u && (o.value = le(u)), o.isBottom = "1" === a, o.isPercent = "1" === e; break; case "aboveAverage": o.subType = Ue.average, o.operator = o.operator || Ve.lessThan; break; case "timePeriod": o.subType = Ue.timePeriod, o.operator = X(l, "timePeriod", void 0); break; case "duplicateValues": o.subType = Ue.duplicateValues; break; case "containsText": o.subType = Ue.text, o.operator = "containsText", o.value = X(l, "text", ""); break; case "colorScale": const c = t.getElementsByTagName("colorScale/cfvo", r, !1), h = t.getElementsByTagName("colorScale/color", r, !1); o.type = We.colorScale, o.config = c.map(((e, t) => { const l = X(e.attributeList, "type", ""), r = X(e.attributeList, "val", void 0); return { index: 0, color: h[t] ? fe(h[t], n) : void 0, value: { type: l, value: le(r) } } })); break; case "dataBar": o.type = We.dataBar; const f = t.getElementsByTagName("dataBar", r, !1)?.[0], g = t.getElementsByTagName("cfvo", f.value, !1), d = t.getElementsByTagName("color", f.value, !1), m = X(f.attributeList, "showValue", "1"); o.isShowValue = "1" === m; let p = d[0] ? fe(d[0], n) : void 0, E = !0, b = ""; if (i) { const e = X(t.getElementsByTagName("x14:dataBar", i.value, !1)[0].attributeList, "gradient", null), l = t.getElementsByTagName("x14:dataBar/x14:negativeFillColor", i.value, !1)?.[0]; b = l ? fe(l, n) : void 0, E = "0" !== e } o.config = { min: { type: X(g[0]?.attributeList, "type", "min"), value: le(X(g[0]?.attributeList, "val", void 0)) }, max: { type: X(g[1]?.attributeList, "type", "max"), value: le(X(g[1]?.attributeList, "val", void 0)) }, isGradient: E, positiveColor: p, nativeColor: b }; break; case "iconSet": if (o.type = We.iconSet, s) { const e = t.getElementsByTagName("x14:iconSet", r, !1)[0], n = t.getElementsByTagName("x14:iconSet/x14:cfvo", r, !1), l = t.getElementsByTagName("x14:iconSet/x14:cfIcon", r, !1), i = "1" === X(e?.attributeList, "custom", "0"); o.isShowValue = "0" !== e?.attributeList?.showValue, o.config = n.map(((n, r) => { const s = t.getElementsByTagName("xm:f", n.value, !1)[0]; let a = l[r]?.attributeList; const o = i ? a?.iconSet : e?.attributeList.iconSet, c = le(o.charAt(0)) - le(a?.iconId) - 1; return { operator: Ve.greaterThanOrEqual, value: { type: n.attributeList.type, value: le(s?.value) }, iconType: o, iconId: c } })).reverse() } else { const e = t.getElementsByTagName("iconSet", r, !1), n = t.getElementsByTagName("iconSet/cfvo", r, !1); o.isShowValue = "0" !== e[0]?.attributeList?.showValue, o.config = n.map(((t, n) => ({ operator: o.operator || Ve.greaterThanOrEqual, value: { type: t.attributeList.type, value: le(t.attributeList.val) }, iconType: e[0].attributeList.iconSet, iconId: n }))) } }const f = X(l, "dxfId", null); if (f) { let e = n.dxfs; const t = null !== f ? e[Number(f)] : void 0, l = t.getInnerElements("font")?.[0], r = t.getInnerElements("numFmt")?.[0], i = t.getInnerElements("fill")?.[0], s = t.getInnerElements("border")?.[0]; let a = n.numfmts, c = {}; if (s) { const { borderCellValue: e } = Ae(s, n); c.border = e } if (i) { const e = Pe(i, n); c.bg = e } if (r) { let e = a[parseInt(r?.attributeList?.numFmtId)], t = new ye; t.fa = e ? U(e) : r.attributeList.formatCode, c.ct = t } if (l) { const { cellValue: e } = _e(l, c); c = { ...c, ...e } } o.style = c } this.rule = o }; const { attributeList: l, parentAttribute: r } = e; r?.sqref && (this.ranges = ke(r.sqref)), this.order = Number(X(l, "priority", "1")), this.cfId = W("condition"), this.stopIfTrue = "1" === X(l, "stopIfTrue", "0"), this.handleRules(e, t, n) } } class qe { constructor(e, t) { let n = e.attributeList, l = e.value, r = X(n, "type", void 0); if (!r) return; this.uid = W("verification"); let i = [], s = ""; const a = X(n, "operator", void 0), o = "1" === X(n, "allowBlank", void 0), c = "1" === X(n, "showInputMessage", void 0), u = "1" === X(n, "showErrorMessage", void 0), h = X(n, "prompt", void 0), f = X(n, "promptTitle", void 0), g = X(n, "error", void 0), d = X(n, "errorTitle", void 0), m = X(n, "errorStyle", "stop"); if (new RegExp(/<x14:formula1>|<xm:sqref>/g).test(l) && t?.length >= 0) { const e = Z(l); s = e?.sqref, i = J(e?.formula) } else i = J(l), s = X(n, "sqref", null); let p = i?.length >= 1 ? i[0] : void 0, E = 2 === i?.length ? i[1] : void 0; switch (s && (this.ranges = ke(s)), this.type = r, this.allowBlank = o, this.operator = a, this.formula1 = p, this.formula2 = E, this.showErrorMessage = u, this.showInputMessage = c, this.prompt = h, this.promptTitle = f, this.error = g, this.errorTitle = d, m) { case "information": this.errorStyle = 0; break; case "warning": this.errorStyle = 2; break; case "stop": this.errorStyle = 1 }this.ranges = ke(s) } } class je { constructor(e, t) { const n = e.getElementsByTagName("autoFilter", t)[0]; if (!n) return; this.ref = ke(n.attributeList.ref)?.[0]; const l = n.getInnerElements("filterColumn"); this.filterColumns = l?.map((e => { const t = e.getInnerElements("customFilters")?.[0], n = e.getInnerElements("filters")?.[0]; let l, r, i = le(e.attributeList.colId); if (i = this.ref ? i + this.ref.startRow : i, t) { const e = t.getInnerElements("customFilter"); l = { and: "1" === t.attributeList?.and ? 1 : void 0, customFilters: e.map((e => ({ val: De(e.attributeList.val), operator: e.attributeList?.operator }))) } } if (n) { const e = n.getInnerElements("filter"); r = { blank: "1" === n.attributeList?.blank, filters: e.map((e => De(e.attributeList.val))) } } return { colId: i, filters: r, customFilters: l } })) } } class Ye { constructor(e) { const t = X(e.attributeList, "xSplit", "0"), n = X(e.attributeList, "ySplit", "0"); this.horizen = Number(n), this.vertical = Number(t) } } const $e = (e, t) => { const n = e.getElementsByTagName("c:barChart", t)[0], l = e.getElementsByTagName("c:lineChart", t)[0], r = e.getElementsByTagName("c:pieChart", t)[0], i = e.getElementsByTagName("c:doughnutChart", t)[0], s = e.getElementsByTagName("c:areaChart", t)[0], a = e.getElementsByTagName("c:radarChart", t)[0], o = e.getElementsByTagName("c:scatterChart", t)[0]; let c = [], u = n, h = F.Column; if (n) { const e = n.getInnerElements("c:barDir")?.[0]?.get("val"), t = n.getInnerElements("c:grouping")?.[0]?.get("val"); "col" === e ? (h = F.Column, "stacked" === t ? h = F.ColumnStacked : "percentStacked" === t && (h = F.ColumnPercentStacked)) : "bar" === e && (h = F.Bar, "stacked" === t ? h = F.BarStacked : "percentStacked" === t && (h = F.BarPercentStacked)), u = n, c.push({ chartEle: u, chartType: h }) } if (l && (u = l, h = F.Line, c.push({ chartEle: u, chartType: h })), r && (u = r, h = F.Pie, c.push({ chartEle: u, chartType: h })), i && (u = i, h = F.Doughnut, c.push({ chartEle: u, chartType: h })), s) { u = s, h = F.Area; const e = s.getInnerElements("c:grouping")?.[0]?.get("val"); "stacked" === e ? h = F.AreaStacked : "percentStacked" === e && (h = F.AreaPercentStacked), c.push({ chartEle: u, chartType: h }) } return a && (u = a, h = F.Radar, c.push({ chartEle: u, chartType: h })), o && (u = o, h = F.Scatter, c.push({ chartEle: u, chartType: h })), c.length > 1 && (h = F.Combination, u = c), { chartEle: u, chartType: h } }; class Ze extends Ne { constructor(e, t, n, l) { super(), this.id = e, this.type = "chart", this.data = { chartType: l, range: n, border: "#979DAC", background: "rgba(0,0,0,0)", isRowDirection: !0 }; let r = 0, i = 0, s = 0, a = 0; const o = t.getInnerElements("a:off")[0], c = t.getInnerElements("a:ext")[0]; s = B(parseInt(c.get("cx"))), a = B(parseInt(c.get("cy"))), r = B(parseInt(o.get("x"))), i = B(parseInt(o.get("y"))), this.transform = { width: s, height: a, top: i, left: r } } } class Je { constructor({ graphicFrame: e, readXml: t, drawingRelsFile: n, styles: l }) { this.getChartRange = e => { let t = 0, n = 0, l = 0, r = 0; if (Array.isArray(e)) e.map((e => this.getChartRef(e.chartEle.value))).forEach(((e, i) => { 0 === i ? (t = e.maxColumn, n = e.maxRow, l = e.minColumn, r = e.minRow) : (t = Math.max(t, e.maxColumn), n = Math.max(n, e.maxRow), l = Math.min(l, e.minColumn), r = Math.min(r, e.minRow)) })); else { const i = this.getChartRef(e.value); t = i.maxColumn, n = i.maxRow, l = i.minColumn, r = i.minRow } const i = ne(t) + (n + 1); return ne(l) + (r + 1) + ":" + i }, this.getChartRef = e => { const t = this.readXml.getElementsByTagName("c:ser/c:cat/c:numRef/c:f", e, !1)?.[0], n = this.readXml.getElementsByTagName("c:ser/c:cat/c:strRef/c:f", e, !1)?.[0], l = this.readXml.getElementsByTagName("c:ser/c:xVal/c:strRef/c:f", e, !1)?.[0], r = this.readXml.getElementsByTagName("c:ser/c:xVal/c:numRef/c:f", e, !1)?.[0], i = t || n || l || r, s = this.readXml.getElementsByTagName("c:ser/c:tx/c:strRef/c:f", e, !1), a = i, o = s[s.length - 1], c = P(a.value), u = P(o.value), h = [...c.column, ...u.column], f = [...c.row, ...u.row]; return { maxColumn: Math.max(...h), maxRow: Math.max(...f), minColumn: Math.min(...h), minRow: Math.min(...f) } }, this.readXml = t; const r = e.getInnerElements("xdr:xfrm")[0], i = function (e) { const { rid: t, fileName: n, callback: l, readXml: r } = e; let i = r.getElementsByTagName("Relationships/Relationship", n); if (null != i && i.length > 0) for (let e = 0; e < i.length; e++) { let n = i[e].attributeList, r = X(n, "Id", null), s = X(n, "Target", null); if (r == t) return s = s.replace(/\.\.\//g, ""), l ? l(s) : s } return null }({ rid: t.getElementsByTagName("a:graphic/a:graphicData/c:chart", e.value, !1)[0].get("r:id"), fileName: n, readXml: t }), { chartEle: s, chartType: a } = $e(t, i), o = this.getChartRange(s), c = re(); this.image = new Ze(c, r, o, a); const u = new Ke({ id: c, range: o, chartType: a, chartFile: i, readXml: t, image: this.image, styles: l }); this.chart = u.model } } class Ke extends Oe { constructor(e) { super(), this.getStyle = e => { const t = this.readXml.getElementsByTagNameLink("c:spPr", this.chartFile)[0], n = t.getInnerElements("a:solidFill")[0], l = t.getInnerElements("a:ln")[0], r = n ? this.getColor(n.getInnerElements("a:schemeClr")[0]) : void 0, i = l ? this.getColor(l.getInnerElements("a:schemeClr")[0]) : void 0, s = this.getAllTitle(), a = this.readXml.getElementsByTagNameLink("c:chart/c:autoTitleDeleted", this.chartFile)[0], o = this.readXml.getElementsByTagNameLink("c:chart/c:plotArea", this.chartFile)[0], c = this.getAxis(o?.getInnerElements("c:catAx")?.[0]), u = this.getAxis(o?.getInnerElements("c:valAx")?.[0]), h = this.readXml.getElementsByTagNameLink("c:chart/c:legend", this.chartFile)[0], f = this.getLegend(h); return { titles: { ...s, titlePosition: "1" === a?.get("val") ? "hide" : "top" }, runtime: {}, width: e.transform.width, height: e.transform.height, backgroundColor: r, borderColor: i, xAxis: c, yAxis: u, legend: f, ...this.getChartSeries() } }, this.getChartSeries = () => { const { chartEle: e, chartType: t } = $e(this.readXml, this.chartFile); if (!e) return {}; if (Array.isArray(e)) return { seriesStyleMap: e.map((e => this.getChartSeriesBase(e.chartEle, e.chartType, !0))).reduce(((e, t) => Object.assign(e, t)), {}) }; const n = e.getInnerElementsTagLink("c:dLbls")[0].getInnerElements("c:showVal")[0]; return { allSeriesStyle: { label: { visible: !!n && "1" === n.get("val") } }, seriesStyleMap: this.getChartSeriesBase(e, t) } }, this.getChartSeriesBase = (e, t, n) => { const l = e.getInnerElements("c:ser"), r = {}; return l.forEach((e => { const l = e.getInnerElements("c:idx")[0], i = parseInt(l.get("val")) + 1, s = e.getInnerElements("c:spPr")[0], a = s?.getInnerElementsTagLink("a:solidFill")?.[0], o = s?.getInnerElements("a:ln")?.[0], c = this.getColor(a?.getInnerElements("a:schemeClr")?.[0]), u = a?.getInnerElements("a:alpha")?.[0]?.get("val"), h = o ? this.getLine(o) : void 0, f = e.getInnerElements("c:dLbls")[0], g = f.getInnerElements("c:showVal")?.[0]?.get("val"), d = f.getInnerElements("c:showCatName")?.[0]?.get("val"), m = f.getInnerElements("c:showSerName")?.[0]?.get("val"), p = f.getInnerElements("c:showPercent")?.[0]?.get("val"), E = this.getBaseStyle(f.getInnerElements("a:defRPr")?.[0]), b = 0 | ("1" === g ? A.Value : 0) | ("1" === d ? A.CategoryName : 0) | ("1" === m ? A.SeriesName : 0) | ("1" === p ? A.Percentage : 0), T = { border: h, label: { visible: !!b, contentType: b, ...E }, color: c, fillOpacity: u ? parseInt(u) / 1e5 : 1, chartType: n ? t : void 0 }; let y = this.getExtraSerise(T, e, t); r[i] = y })), r }, this.getExtraSerise = (e, t, n) => { if (n === F.Line) { e.border?.color && (e.color = e.border.color); const n = t.getInnerElements("c:marker")[0], l = n.getInnerElements("c:symbol")?.[0]?.get("val"), r = n.getInnerElements("c:size")?.[0]?.get("val"), i = n.getInnerElementsTagLink("c:spPr/a:solidFill/a:schemeClr")?.[0], s = this.getColor(i); e.point = { color: s, size: r ? parseInt(r) : void 0, shape: "none" === l && e.label.visible ? "circle" : l } } return e }, this.getLegend = e => { if (!e) return { position: "hide" }; const t = e.getInnerElements("c:legendPos")[0]?.get("val"), n = e.getInnerElements("c:txPr")[0].getInnerElements("a:pPr")[0], l = this.getBaseStyle(n.getInnerElements("a:defRPr")[0]); return { position: t ? { t: "top", b: "bottom", l: "left", r: "right" }[t] : "bottom", label: l } }, this.getAxis = e => { if (!e) return; const t = !e.getInnerElementsTagLink("c:spPr/a:ln/a:noFill")?.length, n = e.getInnerElements("c:scaling")[0], l = "maxMin" === n?.getInnerElements("c:orientation")[0]?.get("val"), r = n?.getInnerElements("c:max")?.[0]?.get("val"), i = n?.getInnerElements("c:min")?.[0]?.get("val"), s = e.getInnerElements("c:lblAlgn")?.[0]?.get("val"), a = e.getInnerElements("c:txPr")[0], o = a.getInnerElements("a:pPr")[0], c = a?.getInnerElements("a:bodyPr")?.[0]?.get("rot"), u = this.getBaseStyle(o.getInnerElements("a:defRPr")[0]), h = e.getInnerElements("c:majorGridlines")?.[0], f = h?.getInnerElements("a:ln")[0], g = f?.get("w") ? B(parseInt(f.get("w"))) : void 0, d = e.getInnerElements("c:majorTickMark")?.[0], m = this.getColor(f?.getInnerElements("a:schemeClr")?.[0]); return { lineVisible: t, reverse: l, max: r ? parseInt(r) : void 0, min: i ? parseInt(i) : void 0, label: { axisTitleAlign: s ? { l: "start", r: "end", ctr: "center" }[s] : "center", rotate: c && parseInt(c) > 0 ? parseInt(c) / 6e4 : 0, ...u }, gridLine: { visible: !!h?.value, width: g, color: m }, tick: { visible: "none" !== d?.get("val"), position: "out" === d?.get("val") ? "outside" : "inside", lineWidth: g } } }, this.getLine = e => { const t = e?.get("w") ? B(parseInt(e.get("w"))) : 0, n = this.getColor(e?.getInnerElements("a:schemeClr")?.[0]), l = e.getInnerElements("a:prstDash")?.[0]?.get("val"), r = { solid: "solid", dot: "dotted", dash: "dashed", sysDot: "dotted", sysDash: "dashed", lgDash: "dashed" }; return { dashType: l && r[l] ? r[l] : "solid", color: n, width: t } }, this.getAllTitle = () => { const e = this.readXml.getElementsByTagNameLink("c:chart/c:title", this.chartFile)[0], t = this.readXml.getElementsByTagNameLink("c:chart/c:plotArea/c:catAx/c:title", this.chartFile)[0], n = this.readXml.getElementsByTagNameLink("c:chart/c:plotArea/c:valAx/c:title", this.chartFile)[0]; return { title: this.getTitle(e), xAxisTitle: this.getTitle(t), yAxisTitle: this.getTitle(n) } }, this.getTitle = e => { if (!e) return; const t = e.getInnerElements("a:r"), n = e.getInnerElements("a:pPr")[0], l = this.getBaseStyle(n.getInnerElements("a:defRPr")[0]), r = t?.map((e => this.getBaseStyle(e.getInnerElements("a:rPr")?.[0]))) || []; return { content: t?.map((e => e.getInnerElements("a:t")[0].value)).join(""), ...l, ...r.length ? r[0] : {} } }, this.getBaseStyle = e => { if (!e) return {}; const t = e.getInnerElements("a:schemeClr")?.[0], n = e.getInnerElements("a:solidFill")?.[0], l = !t && n ? this.getThemColor(n) : this.getColor(t), r = {}; return e.get("sz") && (r.fontSize = parseInt(e.get("sz")) / 100), e.get("b") && (r.bold = "1" === e.get("b")), e.get("i") && (r.italic = "1" === e.get("i")), l && (r.color = l), r }, this.getColor = e => { if (!e) return; const t = e.get("val"), n = this.styles.clrScheme.find((e => { const n = e.getInnerElements("a:sysClr|a:srgbClr")[0]; return !!e.container.includes(t) || ("tx1" === t ? "windowText" === n.get("val") : "bg1" === t && "window" === n.get("val")) })); let l = "#000000"; n && (l = this.getThemColor(n)); const r = e.getInnerElements("a:lumMod")?.[0]?.get("val"), i = e.getInnerElements("a:lumOff")?.[0]?.get("val"); return `rgb(${V(l).map((e => { const t = r ? e * parseInt(r) / 1e5 : e, n = i ? Math.round(parseInt(i) / 1e5 * 255) : 0; return Math.round(t + n) })).join(",")})` }, this.getThemColor = e => { let t = "#000000"; const n = e.getInnerElements("a:sysClr|a:srgbClr"); if (null != n) { const e = n[0], l = e.attributeList; e.container.indexOf("sysClr") > -1 ? null != l.lastClr ? t = "#" + l.lastClr : null != l.val && (t = "#" + l.val) : e.container.indexOf("srgbClr") > -1 && (t = "#" + l.val) } return t }, this.getContext = () => ({ categoryIndex: 0, seriesIndexes: this.readXml.getElementsByTagName("c:ser", this.chartFile).map((e => { const t = e.getInnerElements("c:idx")[0]; return parseInt(t.get("val")) + 1 })) }); const { id: t, range: n, chartType: l, chartFile: r, readXml: i, image: s, styles: a } = e; this.styles = a, this.range = n, this.chartType = l, this.readXml = i, this.chartFile = r, this.isRowDirection = !0, this.id = t, this.context = this.getContext(), this.style = this.getStyle(s) } get model() { return { id: this.id, range: this.range, chartType: this.chartType, context: this.context, style: this.style, isRowDirection: this.isRowDirection } } } class Qe extends pe { constructor(e, t, n, l = !1, r) { super(), this.getImageBaseInfo = (e, t) => { let n = this.readXml.getElementsByTagName("xdr:twoCellAnchor", e), l = this.readXml.getElementsByTagName("xdr:oneCellAnchor", e); if (n = [...n, ...l], null != n && n.length > 0) for (let e = 0; e < n.length; e++) { let l = n[e], r = l.getInnerElements("xdr:from"), i = l.getInnerElements("xdr:to"); if (null != r && r.length > 0) { let e, n, s = r[0]; i ? e = i[0] : n = l.getInnerElements("xdr:ext")[0]; let a = {}; l.getInnerElements("xdr:graphicFrame") && (a = this.getGraphic(l, t)), l.getInnerElements("xdr:pic") && (a = this.getImage(l, t)); let o = 0, c = 0, u = 0, h = 0; if (a.fromCol = this.getXdrValue(s.getInnerElements("xdr:col")), a.fromColOff = B(this.getXdrValue(s.getInnerElements("xdr:colOff"))), a.fromRow = this.getXdrValue(s.getInnerElements("xdr:row")), a.fromRowOff = B(this.getXdrValue(s.getInnerElements("xdr:rowOff"))), e) a.toCol = this.getXdrValue(e.getInnerElements("xdr:col")), a.toColOff = B(this.getXdrValue(e.getInnerElements("xdr:colOff"))), a.toRow = this.getXdrValue(e.getInnerElements("xdr:row")), a.toRowOff = B(this.getXdrValue(e.getInnerElements("xdr:rowOff"))); else { let e = n.attributeList; u = B(parseInt(e.cx)), h = B(parseInt(e.cy)), a.toCol = a.fromCol, a.toColOff = Number(a.fromColOff) + u, a.toRow = a.fromRow, a.toRowOff = Number(a.fromRowOff) + h } a.originWidth = u, a.originHeight = h, a.isFixedPos = !1, a.fixedLeft = 0, a.fixedTop = 0; let f = { color: "#000", radius: 0, style: "solid", width: 0 }; a.border = f; let g = { height: h, offsetLeft: 0, offsetTop: 0, width: u }; a.crop = g; let d = { height: h, left: o, top: c, width: u }; a.default = d, null == this.images && (this.images = {}), a.id && (this.images[a.id || W("image")] = a) } } return null }, this.getImage = (e, t) => { let n = e.getInnerElements("a:blip"), l = X(e.attributeList, "editAs", "twoCell"); if (null != n && n.length > 0) { let e = X(n[0].attributeList, "r:embed", null), r = this.getBase64ByRid(e, t); return r.type = "absolute" == l ? "3" : "oneCell" == l ? "2" : "1", r } return {} }, this.getGraphic = (e, t) => { const n = e.getInnerElements("xdr:graphicFrame"); if (n.length) { const e = n[0], l = new Je({ graphicFrame: e, readXml: this.readXml, drawingRelsFile: t, styles: this.styles }), r = l.image; return l.chart && (null == this.charts && (this.charts = []), this.charts.push(l.chart)), r } return {} }, this.getCellSize = e => { let t = e.attributeList, n = t.r; t.s, t.t; let l = P(n); const r = l.row[0], i = l.column[0]; return { width: this.config.columnlen && this.config.columnlen[i] ? this.config.columnlen[i] : this.defaultColWidth, height: this.config.rowlen && this.config.rowlen[r] ? this.config.rowlen[r] : this.defaultRowHeight } }, this.isInitialCell = l, this.readXml = r.readXml, this.sheetFile = r.sheetFile, this.styles = r.styles, this.sharedStrings = r.sharedStrings, this.calcChainEles = r.calcChain, this.sheetList = r.sheetList, this.imageList = r.imageList, this.hide = r.hide, this.cellImages = r.cellImages, this.name = e, this.index = t, this.order = n.toString(), this.config = new we, this.celldata = [], this.mergeCells = this.readXml.getElementsByTagName("mergeCells/mergeCell", this.sheetFile), this.styles.clrScheme; let i = this.readXml.getElementsByTagName("sheetViews/sheetView", this.sheetFile), s = "1", a = "0", o = "100", c = "A1"; if (i.length > 0) { let e = i[0].attributeList; s = X(e, "showGridLines", "1"), a = X(e, "tabSelected", "0"), o = X(e, "zoomScale", "100"); let t = i[0].getInnerElements("selection"); if (null != t && t.length > 0) { c = X(t[0].attributeList, "activeCell", "A1"); let e = P(c); this.luckysheet_select_save = [], this.luckysheet_select_save.push(e) } let n = i[0].getInnerElements("pane"); n?.length > 0 && (this.freezen = new Ye(n[0])) } this.showGridLines = s, this.status = a, this.zoomRatio = parseInt(o) / 100; let u = this.readXml.getElementsByTagName("sheetPr/tabColor", this.sheetFile); if (null != u && u.length > 0) { let e = u[0]; e.attributeList; let t = fe(e, this.styles, "b"); this.color = t } let h, f, g = this.readXml.getElementsByTagName("sheetFormatPr", this.sheetFile); if (g.length > 0) { let e = g[0].attributeList; h = X(e, "defaultColWidth", "9.21"), f = X(e, "defaultRowHeight", "19") } this.defaultColWidth = G(parseFloat(h)), this.defaultRowHeight = H(parseFloat(f)), this.generateConfigColumnLenAndHidden(); let d = this.generateConfigRowLenAndHiddenAddCell(); null == this.calcChain && (this.calcChain = []); let m = {}; for (let e = 0; e < this.calcChainEles.length; e++) { let n = this.calcChainEles[e].attributeList; if (n.i != t) continue; let l = n.r; n.i, n.l, n.s, n.a, n.t; let r = P(l), i = new Se; i.r = r.row[0], i.c = r.column[0], i.index = this.index, this.calcChain.push(i), m["r" + l + "c" + e] = null } if (null != this.formulaRefList) for (let e in this.formulaRefList) { let t = this.formulaRefList[e], n = t.mainRef, l = n.cellValue, r = n.fv, i = l.r, s = l.c; for (let e in t) { if ("mainRef" == e) continue; let n = t[e].cellValue; if (null == n) continue; let l = r, a = n.r - i, o = n.c - s; a > 0 ? l = "=" + z.functionCopy(l, "down", a) : a < 0 && (l = "=" + z.functionCopy(l, "up", Math.abs(a))), o > 0 ? l = "=" + z.functionCopy(l, "right", o) : o < 0 && (l = "=" + z.functionCopy(l, "left", Math.abs(o))), n.v.f = l; let c = new Se; c.r = n.r, c.c = n.c, c.index = this.index, this.calcChain.push(c) } } for (let e in d.formulaList) if (!(e in m)) { let t = d.formulaList[e], n = new Se; n.r = t.r, n.c = t.c, n.index = this.index, this.calcChain.push(n) } const p = this.readXml.getElementsByTagName("conditionalFormatting", this.sheetFile), E = this.readXml.getElementsByTagName("extLst/ext/x14:conditionalFormattings/x14:conditionalFormatting", this.sheetFile) || [], b = E?.map((e => { const t = this.readXml.getElementsByTagName("xm:sqref", e.value, !1)?.[0]; return this.readXml.getElementsByTagName("x14:cfRule", e.value, !1).map((e => ({ ...e, parentAttribute: { sqref: t?.value }, isExtLst: !0, extLst: void 0 }))) }))?.flat() || []; if (p?.length) { const e = p.map((e => this.readXml.getElementsByTagName("cfRule", e.value, !1)?.map((t => ({ ...t, parentAttribute: e.attributeList, extLst: b.find((t => t.parentAttribute.sqref === e.attributeList?.sqref)) })))))?.flat().filter(Boolean).concat(b?.filter((e => -1 === p.findIndex((t => t.attributeList.sqref === e.parentAttribute.sqref))))) || []; this.conditionalFormatting = e.map((e => new ze(e, this.readXml, this.styles))) } const T = new je(this.readXml, this.sheetFile); if (T.ref && (this.filter = T), this.dataVerification = this.generateConfigDataValidations(), this.dataVerificationList = this.generateConfigDataValidationsList(), this.hyperlink = this.generateConfigHyperlinks(), this.hide = this.hide, null != this.mergeCells) for (let e = 0; e < this.mergeCells.length; e++) { let t = this.mergeCells[e].attributeList.ref; if (null == t) continue; let n = P(t), l = new Le; l.r = n.row[0], l.c = n.column[0], l.rs = n.row[1] - n.row[0] + 1, l.cs = n.column[1] - n.column[0] + 1, null == this.config.merge && (this.config.merge = {}), this.config.merge[n.row[0] + "_" + n.column[0]] = l } let y = r.drawingFile, v = r.drawingRelsFile; null != y && null != v && this.getImageBaseInfo(y, v) } getXdrValue(e) { return null == e || 0 == e.length ? null : parseInt(e[0].value) } getBase64ByRid(e, t) { let n = this.readXml.getElementsByTagName("Relationships/Relationship", t); if (null != n && n.length > 0) for (let t = 0; t < n.length; t++) { let l = n[t].attributeList, r = X(l, "Id", null), i = X(l, "Target", null); if (r == e) return i = i.replace(/\.\.\//g, ""), i = "xl/" + i, this.imageList.getImageByName(i) } return {} } generateConfigColumnLenAndHidden() { let e = this.readXml.getElementsByTagName("cols/col", this.sheetFile); for (let t = 0; t < e.length; t++) { let n = e[t].attributeList, l = X(n, "min", null), r = X(n, "max", null), i = X(n, "width", null), s = X(n, "hidden", null), a = X(n, "customWidth", null); if (null == l || null == r) continue; let o = parseInt(l) - 1, c = parseInt(r) - 1, u = parseFloat(i); for (let e = o; e <= c; e++)null != i && (null == this.config.columnlen && (this.config.columnlen = {}), this.config.columnlen[e] = G(u)), "1" == s && (null == this.config.colhidden && (this.config.colhidden = {}), this.config.colhidden[e] = 0), null != a && (null == this.config.customWidth && (this.config.customWidth = {}), this.config.customWidth[e] = 1) } } generateConfigRowLenAndHiddenAddCell() { let e = this.readXml.getElementsByTagName("sheetData/row", this.sheetFile), t = { formulaList: {} }; for (let n = 0; n < e.length; n++) { let l = e[n], r = l.attributeList, i = X(r, "r", null), s = X(r, "ht", null), a = X(r, "hidden", null), o = X(r, "customHeight", null); if (null == i) continue; let c = parseInt(i) - 1; if (null != s) { let e = parseFloat(s); null == this.config.rowlen && (this.config.rowlen = {}), this.config.rowlen[c] = H(e) } if ("1" == a && (null == this.config.rowhidden && (this.config.rowhidden = {}), this.config.rowhidden[c] = 0), null != o && (null == this.config.customHeight && (this.config.customHeight = {}), this.config.customHeight[c] = 1), this.isInitialCell) { let e = l.getInnerElements("c"); for (let n in e) { let l = e[n]; const r = this.getCellSize(l); let i = new Xe(l, r, this.styles, this.sharedStrings, this.mergeCells, this.sheetFile, this.cellImages, this.imageList, this.readXml); if (null != i._borderObject && (null == this.config.borderInfo && (this.config.borderInfo = []), this.config.borderInfo.push(i._borderObject), delete i._borderObject), "shared" == i._formulaType) { let e; null == this.formulaRefList && (this.formulaRefList = {}), null == this.formulaRefList[i._formulaSi] && (this.formulaRefList[i._formulaSi] = {}), null != i.v && (e = i.v.f); let t = { t: i._formulaType, ref: i._fomulaRef, si: i._formulaSi, fv: e, cellValue: i }; null != i._fomulaRef ? this.formulaRefList[i._formulaSi].mainRef = t : this.formulaRefList[i._formulaSi][i.r + "_" + i.c] = t } if (null != i.v && null != i.v.f) { let e = { r: i.r, c: i.c }; t.formulaList["r" + i.r + "c" + i.c] = e } this.celldata.push(i) } } } return t } generateConfigDataValidationsList() { let e = this.readXml.getElementsByTagName("dataValidations/dataValidation", this.sheetFile), t = this.readXml.getElementsByTagName("extLst/ext/x14:dataValidations/x14:dataValidation", this.sheetFile) || []; return e = e.concat(t), e.map((e => new qe(e, t))).filter((e => e.uid)) } generateConfigDataValidations() { let e = this.readXml.getElementsByTagName("dataValidations/dataValidation", this.sheetFile), t = this.readXml.getElementsByTagName("extLst/ext/x14:dataValidations/x14:dataValidation", this.sheetFile) || []; e = e.concat(t); let n = {}; for (let r = 0; r < e.length; r++) { let i = e[r], s = i.attributeList, a = i.value, o = X(s, "type", null); if (!o) continue; let c = "", u = "", h = [], f = [], g = "1" === X(s, "allowBlank", null); if (new RegExp(/<x14:formula1>|<xm:sqref>/g).test(a) && t?.length >= 0) { c = X(s, "operator", null); const e = Z(a); u = e?.sqref, h = j(u), f = J(e?.formula) } else c = X(s, "operator", null), u = X(s, "sqref", null), h = j(u), f = J(a); let d = x[o], m = null, p = f?.length >= 1 ? f[0] : "", E = 2 === f?.length ? f[1] : "", b = X(s, "prompt", null), T = !!b; const y = N.includes(d) || !O[d] ? "common" : d; if (m = c ? O[y][c] : "bw", "text_content" === d && (p?.includes("LEN") || p?.includes("len")) && p?.includes("=11") && (d = "validity", m = "phone"), "date" === d) { const e = new Date(1899, 11, 30, 0, 0, 0); p = l(e).clone().add(Number(p), "day").format("YYYY-MM-DD"), E = l(e).clone().add(Number(E), "day").format("YYYY-MM-DD") } "checkbox" !== d && "dropdown" !== d || (m = null); for (const e of h) n[e] = { type: d, type2: m, value1: p, value2: E, checked: !1, remote: !1, prohibitInput: g, hintShow: T, hintText: b } } return n } generateConfigHyperlinks() { let e = this.readXml.getElementsByTagName("hyperlinks/hyperlink", this.sheetFile), t = {}; for (let n = 0; n < e.length; n++) { let l = e[n].attributeList, r = j(X(l, "ref", null)), i = X(l, "display", null), s = X(l, "location", null), a = X(l, "tooltip", null), o = s ? "internal" : "external"; if (!s) { let e = l["r:id"], t = this.sheetFile, n = this.readXml.getElementsByTagName("Relationships/Relationship", `xl/worksheets/_rels/${t.replace("xl/worksheets/", "")}.rels`); const r = n?.find((t => t.attributeList.Id === e)); r && (s = r.attributeList.Target, o = r.attributeList.TargetMode?.toLocaleLowerCase()) } new RegExp(/^.*!R([\d$])+C([\d$])*$/g).test(s) && (s = $(s)); for (const e of r) t[e] = { linkAddress: s, linkTooltip: a || "", linkType: o, display: i || "" } } return t } } let et = {}; et.G = { concat: function (e, t) { for (var n = 0; n < t.cmds.length; n++)e.cmds.push(t.cmds[n]); for (n = 0; n < t.crds.length; n++)e.crds.push(t.crds[n]) }, getBB: function (e) { for (var t = 1e99, n = 1e99, l = -t, r = -n, i = 0; i < e.length; i += 2) { var s = e[i], a = e[i + 1]; s < t ? t = s : s > l && (l = s), a < n ? n = a : a > r && (r = a) } return [t, n, l, r] }, rectToPath: function (e) { return { cmds: ["M", "L", "L", "L", "Z"], crds: [e[0], e[1], e[2], e[1], e[2], e[3], e[0], e[3]] } }, insideBox: function (e, t) { return t[0] <= e[0] && t[1] <= e[1] && e[2] <= t[2] && e[3] <= t[3] }, isBox: function (e, t) { var n = function (e, t) { for (var n = 0; n < 8; n += 2) { for (var l = !0, r = 0; r < 8; r++)if (Math.abs(t[r] - e[r + n & 7]) >= 2) { l = !1; break } if (l) return !0 } return !1 }; if (e.cmds.length > 10) return !1; var l = e.cmds.join(""), r = e.crds, i = !1; if ("MLLLZ" == l && 8 == r.length || "MLLLLZ" == l && 10 == r.length) { 10 == r.length && (r = r.slice(0, 8)); var s = t[0], a = t[1], o = t[2], c = t[3]; i || (i = n(r, [s, a, o, a, o, c, s, c])), i || (i = n(r, [s, c, o, c, o, a, s, a])) } return i }, boxArea: function (e) { return (e[2] - e[0]) * (e[3] - e[1]) }, newPath: function (e) { e.pth = { cmds: [], crds: [] } }, moveTo: function (e, t, n) { var l = et.M.multPoint(e.ctm, [t, n]); e.pth.cmds.push("M"), e.pth.crds.push(l[0], l[1]), e.cpos = l }, lineTo: function (e, t, n) { var l = et.M.multPoint(e.ctm, [t, n]); e.cpos[0] == l[0] && e.cpos[1] == l[1] || (e.pth.cmds.push("L"), e.pth.crds.push(l[0], l[1]), e.cpos = l) }, curveTo: function (e, t, n, l, r, i, s) { var a; t = (a = et.M.multPoint(e.ctm, [t, n]))[0], n = a[1], l = (a = et.M.multPoint(e.ctm, [l, r]))[0], r = a[1], i = (a = et.M.multPoint(e.ctm, [i, s]))[0], s = a[1], e.cpos = a, e.pth.cmds.push("C"), e.pth.crds.push(t, n, l, r, i, s) }, closePath: function (e) { e.pth.cmds.push("Z") }, arc: function (e, t, n, l, r, i, s) { if (s) for (; i > r;)i -= 2 * Math.PI; else for (; i < r;)i += 2 * Math.PI; var a = (i - r) / 4, o = Math.cos(a / 2), c = -Math.sin(a / 2), u = (4 - o) / 3, h = 0 == c ? c : (1 - o) * (3 - o) / (3 * c), f = u, g = -h, d = o, m = -c, p = [u, h], E = [f, g], b = [d, m], T = { cmds: [0 == e.pth.cmds.length ? "M" : "L", "C", "C", "C", "C"], crds: [o, c, u, h, f, g, d, m] }, y = [1, 0, 0, 1, 0, 0]; et.M.rotate(y, -a); for (var v = 0; v < 3; v++)p = et.M.multPoint(y, p), E = et.M.multPoint(y, E), b = et.M.multPoint(y, b), T.crds.push(p[0], p[1], E[0], E[1], b[0], b[1]); var w = [l, 0, 0, l, t, n]; et.M.rotate(y, a / 2 - r), et.M.concat(y, w), et.M.multArray(y, T.crds), et.M.multArray(e.ctm, T.crds), et.G.concat(e.pth, T), n = T.crds.pop(), t = T.crds.pop(), e.cpos = [t, n] }, toPoly: function (e) { if ("M" != e.cmds[0] || "Z" != e.cmds[e.cmds.length - 1]) return null; for (var t = 1; t < e.cmds.length - 1; t++)if ("L" != e.cmds[t]) return null; var n = [], l = e.crds.length; for (e.crds[0] == e.crds[l - 2] && e.crds[1] == e.crds[l - 1] && (l -= 2), t = 0; t < l; t += 2)n.push([e.crds[t], e.crds[t + 1]]); return et.G.polyArea(e.crds) < 0 && n.reverse(), n }, fromPoly: function (e) { for (var t = { cmds: [], crds: [] }, n = 0; n < e.length; n++)t.crds.push(e[n][0], e[n][1]), t.cmds.push(0 == n ? "M" : "L"); return t.cmds.push("Z"), t }, polyArea: function (e) { if (e.length < 6) return 0; for (var t = e.length - 2, n = (e[0] - e[t]) * (e[t + 1] + e[1]), l = 0; l < t; l += 2)n += (e[l + 2] - e[l]) * (e[l + 1] + e[l + 3]); return .5 * -n }, polyClip: function (e, t) { var n, l, r = function (e) { return (a[0] - n[0]) * (e[1] - n[1]) > (a[1] - n[1]) * (e[0] - n[0]) }, i = function () { var e = [n[0] - a[0], n[1] - a[1]], t = [l[0] - c[0], l[1] - c[1]], r = n[0] * a[1] - n[1] * a[0], i = l[0] * c[1] - l[1] * c[0], s = 1 / (e[0] * t[1] - e[1] * t[0]); return [(r * t[0] - i * e[0]) * s, (r * t[1] - i * e[1]) * s] }, s = e; n = t[t.length - 1]; for (let e in t) { var a = t[e], o = s; s = [], l = o[o.length - 1]; for (let e in o) { var c; r(c = o[e]) ? (r(l) || s.push(i()), s.push(c)) : r(l) && s.push(i()), l = c } n = a } return s } }, et.M = { getScale: function (e) { return Math.sqrt(Math.abs(e[0] * e[3] - e[1] * e[2])) }, translate: function (e, t, n) { et.M.concat(e, [1, 0, 0, 1, t, n]) }, rotate: function (e, t) { et.M.concat(e, [Math.cos(t), -Math.sin(t), Math.sin(t), Math.cos(t), 0, 0]) }, scale: function (e, t, n) { et.M.concat(e, [t, 0, 0, n, 0, 0]) }, concat: function (e, t) { var n = e[0], l = e[1], r = e[2], i = e[3], s = e[4], a = e[5]; e[0] = n * t[0] + l * t[2], e[1] = n * t[1] + l * t[3], e[2] = r * t[0] + i * t[2], e[3] = r * t[1] + i * t[3], e[4] = s * t[0] + a * t[2] + t[4], e[5] = s * t[1] + a * t[3] + t[5] }, invert: function (e) { var t = e[0], n = e[1], l = e[2], r = e[3], i = e[4], s = e[5], a = t * r - n * l; e[0] = r / a, e[1] = -n / a, e[2] = -l / a, e[3] = t / a, e[4] = (l * s - r * i) / a, e[5] = (n * i - t * s) / a }, multPoint: function (e, t) { var n = t[0], l = t[1]; return [n * e[0] + l * e[2] + e[4], n * e[1] + l * e[3] + e[5]] }, multArray: function (e, t) { for (var n = 0; n < t.length; n += 2) { var l = t[n], r = t[n + 1]; t[n] = l * e[0] + r * e[2] + e[4], t[n + 1] = l * e[1] + r * e[3] + e[5] } } }, et.C = { srgbGamma: function (e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055 }, cmykToRgb: function (e) { var t = e[0], n = e[1], l = e[2], r = e[3], i = 255 + t * (-4.387332384609988 * t + 54.48615194189176 * n + 18.82290502165302 * l + 212.25662451639585 * r - 285.2331026137004) + n * (1.7149763477362134 * n - 5.6096736904047315 * l + -17.873870861415444 * r - 5.497006427196366) + l * (-2.5217340131683033 * l - 21.248923337353073 * r + 17.5119270841813) + r * (-21.86122147463605 * r - 189.48180835922747), s = 255 + t * (8.841041422036149 * t + 60.118027045597366 * n + 6.871425592049007 * l + 31.159100130055922 * r - 79.2970844816548) + n * (-15.310361306967817 * n + 17.575251261109482 * l + 131.35250912493976 * r - 190.9453302588951) + l * (4.444339102852739 * l + 9.8632861493405 * r - 24.86741582555878) + r * (-20.737325471181034 * r - 187.80453709719578), a = 255 + t * (.8842522430003296 * t + 8.078677503112928 * n + 30.89978309703729 * l - .23883238689178934 * r - 14.183576799673286) + n * (10.49593273432072 * n + 63.02378494754052 * l + 50.606957656360734 * r - 112.23884253719248) + l * (.03296041114873217 * l + 115.60384449646641 * r - 193.58209356861505) + r * (-22.33816807309886 * r - 180.12613974708367); return [Math.max(0, Math.min(1, i / 255)), Math.max(0, Math.min(1, s / 255)), Math.max(0, Math.min(1, a / 255))] }, labToRgb: function (e) { for (var t = 903.3, n = .008856, l = e[0], r = e[1], i = (l + 16) / 116, s = i * i * i, a = i - e[2] / 200, o = a * a * a, c = r / 500 + i, u = c * c * c, h = [96.72 * (u > n ? u : (116 * c - 16) / t) / 100, 100 * (s > n ? s : (116 * i - 16) / t) / 100, 81.427 * (o > n ? o : (116 * a - 16) / t) / 100], f = [3.1338561, -1.6168667, -.4906146, -.9787684, 1.9161415, .033454, .0719453, -.2289914, 1.4052427], g = [f[0] * h[0] + f[1] * h[1] + f[2] * h[2], f[3] * h[0] + f[4] * h[1] + f[5] * h[2], f[6] * h[0] + f[7] * h[1] + f[8] * h[2]], d = 0; d < 3; d++)g[d] = Math.max(0, Math.min(1, et.C.srgbGamma(g[d]))); return g } }, et.getState = function (e) { return { font: et.getFont(), dd: { flat: 1 }, space: "/DeviceGray", ca: 1, colr: [0, 0, 0], sspace: "/DeviceGray", CA: 1, COLR: [0, 0, 0], bmode: "/Normal", SA: !1, OPM: 0, AIS: !1, OP: !1, op: !1, SMask: "/None", lwidth: 1, lcap: 0, ljoin: 0, mlimit: 10, SM: .1, doff: 0, dash: [], ctm: [1, 0, 0, 1, 0, 0], cpos: [0, 0], pth: { cmds: [], crds: [] }, cpth: e ? et.G.rectToPath(e) : null } }, et.getFont = function () { return { Tc: 0, Tw: 0, Th: 100, Tl: 0, Tf: "Helvetica-Bold", Tfs: 1, Tmode: 0, Trise: 0, Tk: 0, Tal: 0, Tun: 0, Tm: [1, 0, 0, 1, 0, 0], Tlm: [1, 0, 0, 1, 0, 0], Trm: [1, 0, 0, 1, 0, 0] } }; let tt = function () { }; tt.Parse = function (e, t) { e = new Uint8Array(e); for (var n, l = 0, r = { fill: !1, strk: !1, bb: [0, 0, 1, 1], wbb: [0, 0, 1, 1], fnt: { nam: "Arial", hgh: 25, und: !1, orn: 0 }, tclr: [0, 0, 0], talg: 0 }, i = [], s = [], a = tt.B.readShort, o = tt.B.readUshort, c = tt.B.readInt, u = tt.B.readUint, h = tt.B.readFloat; ;) { var f = u(e, l); l += 4; var g = tt.K[f], d = u(e, l), m = l += 4, p = null, E = 0; if ("EOF" == g) break; if ("HEADER" == g) r.bb = tt._readBox(e, m), m += 16, t.StartPage(r.bb[0], r.bb[1], r.bb[2], r.bb[3]), n = et.getState(r.bb); else if ("SAVEDC" == g) s.push(JSON.stringify(n), JSON.stringify(r)); else if ("RESTOREDC" == g) { var b = c(e, m); for (m += 4; b < -1;)s.pop(), s.pop(); r = JSON.parse(s.pop()), n = JSON.parse(s.pop()) } else if ("SELECTCLIPPATH" == g) n.cpth = JSON.parse(JSON.stringify(n.pth)); else if (-1 != ["SETMAPMODE", "SETPOLYFILLMODE", "SETBKMODE", "SETICMMODE", "SETROP2", "EXTSELECTCLIPRGN"].indexOf(g)); else if ("SETMITERLIMIT" == g) n.mlimit = u(e, m); else if ("SETTEXTCOLOR" == g) r.tclr = [e[m] / 255, e[m + 1] / 255, e[m + 2] / 255]; else if ("SETTEXTALIGN" == g) r.talg = u(e, m); else if ("SETVIEWPORTEXTEX" == g || "SETVIEWPORTORGEX" == g) { null == r.vbb && (r.vbb = []); var T = "SETVIEWPORTORGEX" == g ? 0 : 2; r.vbb[T] = c(e, m), m += 4, r.vbb[T + 1] = c(e, m), m += 4, "SETVIEWPORTEXTEX" == g && tt._updateCtm(r, n) } else if ("SETWINDOWEXTEX" == g || "SETWINDOWORGEX" == g) T = "SETWINDOWORGEX" == g ? 0 : 2, r.wbb[T] = c(e, m), m += 4, r.wbb[T + 1] = c(e, m), m += 4, "SETWINDOWEXTEX" == g && tt._updateCtm(r, n); else if ("COMMENT" == g) u(e, m), m += 4; else if ("SELECTOBJECT" == g) { var y = u(e, m); if (m += 4, 2147483648 == y) r.fill = !0, n.colr = [1, 1, 1]; else if (2147483653 == y) r.fill = !1; else if (2147483655 == y) r.strk = !0, r.lwidth = 1, n.COLR = [0, 0, 0]; else if (2147483656 == y) r.strk = !1; else if (2147483661 == y); else if (2147483662 == y); else { var v = i[y]; if ("b" == v.t) { if (r.fill = 1 != v.stl, 0 == v.stl); else if (1 != v.stl) throw v.stl + " e"; n.colr = v.clr } else if ("p" == v.t) r.strk = 5 != v.stl, n.lwidth = v.wid, n.COLR = v.clr; else { if ("f" != v.t) throw "e"; r.fnt = v, n.font.Tf = v.nam, n.font.Tfs = Math.abs(v.hgh), n.font.Tun = v.und } } } else if ("DELETEOBJECT" == g) { if (y = u(e, m), m += 4, null == i[y]) throw "e"; i[y] = null } else if ("CREATEBRUSHINDIRECT" == g) E = u(e, m), (p = { t: "b" }).stl = u(e, m += 4), m += 4, p.clr = [e[m] / 255, e[m + 1] / 255, e[m + 2] / 255], m += 4, p.htc = u(e, m), m += 4; else if ("CREATEPEN" == g || "EXTCREATEPEN" == g) E = u(e, m), m += 4, p = { t: "p" }, "EXTCREATEPEN" == g ? (m += 16, p.stl = u(e, m), m += 4, p.wid = u(e, m), m += 4, m += 4) : (p.stl = u(e, m), m += 4, p.wid = u(e, m), m += 4, m += 4), p.clr = [e[m] / 255, e[m + 1] / 255, e[m + 2] / 255], m += 4; else if ("EXTCREATEFONTINDIRECTW" == g) { E = u(e, m), (p = { t: "f", nam: "" }).hgh = c(e, m += 4), m += 4, m += 8, p.orn = c(e, m) / 10; var w = u(e, m += 4); for (m += 4, p.und = e[m + 1], p.stk = e[m + 2], m += 8; 0 != o(e, m);)p.nam += String.fromCharCode(o(e, m)), m += 2; w > 500 && (p.nam += "-Bold") } else if ("EXTTEXTOUTW" == g) { var I = u(e, m += 16); h(e, m += 4), h(e, m += 4); var R = c(e, m += 4), C = c(e, m += 4); m += 4, n.font.Tm = [1, 0, 0, -1, 0, 0], et.M.rotate(n.font.Tm, r.fnt.orn * Math.PI / 180), et.M.translate(n.font.Tm, R, C); var L = r.talg; if (6 & ~L) { if (7 & L) throw L + " e"; n.font.Tal = 0 } else n.font.Tal = 2; if (24 & ~L) { if (24 & L) throw "e"; et.M.translate(n.font.Tm, 0, n.font.Tfs) } var S = u(e, m), x = u(e, m += 4); u(e, m += 4), m += 4, u(e, m += 16), m += 4, x += l - 8; for (var N = "", O = 0; O < S; O++) { var M = o(e, x + 2 * O); N += String.fromCharCode(M) } var F = n.colr; n.colr = r.tclr, t.PutText(n, N, N.length * n.font.Tfs * .5), n.colr = F } else if ("BEGINPATH" == g) et.G.newPath(n); else if ("ENDPATH" == g); else if ("CLOSEFIGURE" == g) et.G.closePath(n); else if ("MOVETOEX" == g) et.G.moveTo(n, c(e, m), c(e, m + 4)); else if ("LINETO" == g) { if (0 == n.pth.cmds.length) { var A = n.ctm.slice(0); et.M.invert(A); var P = et.M.multPoint(A, n.cpos); et.G.moveTo(n, P[0], P[1]) } et.G.lineTo(n, c(e, m), c(e, m + 4)) } else if ("POLYGON" == g || "POLYGON16" == g || "POLYLINE" == g || "POLYLINE16" == g || "POLYLINETO" == g || "POLYLINETO16" == g) { m += 16; var _ = g.startsWith("POLYGON"), k = -1 != g.indexOf("TO"), B = u(e, m); m += 4, k || et.G.newPath(n), m = tt._drawPoly(e, m, B, n, g.endsWith("16") ? 2 : 4, _, k), k || tt._draw(t, n, r, _) } else if ("POLYPOLYGON16" == g) { m += 16, _ = g.startsWith("POLYPOLYGON"), k = -1 != g.indexOf("TO"); var D = u(e, m); m += 4; var X = m += 4; for (m += 4 * D, k || et.G.newPath(n), O = 0; O < D; O++) { var G = o(e, X + 4 * O); m = tt._drawPoly(e, m, G, n, g.endsWith("16") ? 2 : 4, _, k) } k || tt._draw(t, n, r, _) } else if ("POLYBEZIER" == g || "POLYBEZIER16" == g || "POLYBEZIERTO" == g || "POLYBEZIERTO16" == g) { m += 16; var H = g.endsWith("16"), V = H ? a : c, W = H ? 2 : 4; for (B = u(e, m), m += 4, -1 == g.indexOf("TO") && (et.G.moveTo(n, V(e, m), V(e, m + W)), m += 2 * W, B--); B > 0;)et.G.curveTo(n, V(e, m), V(e, m + W), V(e, m + 2 * W), V(e, m + 3 * W), V(e, m + 4 * W), V(e, m + 5 * W)), m += 6 * W, B -= 3 } else if ("RECTANGLE" == g || "ELLIPSE" == g) { et.G.newPath(n); var U = tt._readBox(e, m); if ("RECTANGLE" == g) et.G.moveTo(n, U[0], U[1]), et.G.lineTo(n, U[2], U[1]), et.G.lineTo(n, U[2], U[3]), et.G.lineTo(n, U[0], U[3]); else { var z = (U[0] + U[2]) / 2, q = (U[1] + U[3]) / 2; et.G.arc(n, z, q, (U[2] - U[0]) / 2, 0, 2 * Math.PI, !1) } et.G.closePath(n), tt._draw(t, n, r, !0) } else if ("FILLPATH" == g) t.Fill(n, !1); else if ("STROKEPATH" == g) t.Stroke(n); else if ("STROKEANDFILLPATH" == g) t.Fill(n, !1), t.Stroke(n); else if ("SETWORLDTRANSFORM" == g || "MODIFYWORLDTRANSFORM" == g) { var j = []; for (O = 0; O < 6; O++)j.push(h(e, m + 4 * O)); if (m += 24, "SETWORLDTRANSFORM" == g) n.ctm = j; else { if (I = u(e, m), m += 4, 2 != I) throw "e"; var Y = n.ctm; n.ctm = j, et.M.concat(n.ctm, Y) } } else if ("SETSTRETCHBLTMODE" == g) u(e, m), m += 4; else if ("STRETCHDIBITS" == g) { U = tt._readBox(e, m); var $ = c(e, m += 16), Z = c(e, m += 4); c(e, m += 4), c(e, m += 4); var J = c(e, m += 4), K = c(e, m += 4), Q = u(e, m += 4) + l - 8; u(e, m += 4); var ee = u(e, m += 4) + l - 8; if (u(e, m += 4), 0 != u(e, m += 4)) throw "e"; u(e, m += 4); var te = c(e, m += 4), ne = c(e, m += 4); m += 4, u(e, Q); var le = u(e, Q += 4), re = u(e, Q += 4); if (le != J || re != K) throw "e"; var ie = o(e, Q += 4), se = o(e, Q += 2); if (8 != se && 24 != se && 32 != se) throw se + " e"; var ae = u(e, Q += 2); if (0 != ae) throw ae + " e"; u(e, Q += 4), u(e, Q += 4), u(e, Q += 4), u(e, Q += 4), u(e, Q += 4), Q += 4; var oe = Math.floor((le * ie * se + 31 & -32) / 8), ce = new Uint8Array(le * re * 4); if (8 == se) for (q = 0; q < re; q++)for (z = 0; z < le; z++) { var ue = q * le + z << 2; y = e[ee + (re - 1 - q) * oe + z] << 2, ce[ue] = e[Q + y + 2], ce[ue + 1] = e[Q + y + 1], ce[ue + 2] = e[Q + y + 0], ce[ue + 3] = 255 } if (24 == se) for (q = 0; q < re; q++)for (z = 0; z < le; z++) { var he = ee + (re - 1 - q) * oe + 3 * z; ce[ue = q * le + z << 2] = e[he + 2], ce[ue + 1] = e[he + 1], ce[ue + 2] = e[he + 0], ce[ue + 3] = 255 } if (32 == se) for (q = 0; q < re; q++)for (z = 0; z < le; z++)he = ee + (re - 1 - q) * oe + 4 * z, ce[ue = q * le + z << 2] = e[he + 2], ce[ue + 1] = e[he + 1], ce[ue + 2] = e[he + 0], ce[ue + 3] = e[he + 3]; var fe = n.ctm.slice(0); n.ctm = [1, 0, 0, 1, 0, 0], et.M.scale(n.ctm, te, -ne), et.M.translate(n.ctm, $, Z + ne), et.M.concat(n.ctm, fe), t.PutImage(n, ce, le, re), n.ctm = fe } null != p && (i[E] = p), l += d - 8 } t.ShowPage(), t.Done() }, tt._readBox = function (e, t) { for (var n = [], l = 0; l < 4; l++)n[l] = tt.B.readInt(e, t + 4 * l); return n }, tt._updateCtm = function (e, t) { var n = [1, 0, 0, 1, 0, 0], l = e.wbb; e.bb; var r = e.vbb && 4 == e.vbb.length ? e.vbb : e.bb; et.M.translate(n, -l[0], -l[1]), et.M.scale(n, 1 / l[2], 1 / l[3]), et.M.scale(n, r[2], r[3]), t.ctm = n }, tt._draw = function (e, t, n, l) { n.fill && l && e.Fill(t, !1), n.strk && 0 != t.lwidth && e.Stroke(t) }, tt._drawPoly = function (e, t, n, l, r, i, s) { for (var a = 2 == r ? tt.B.readShort : tt.B.readInt, o = 0; o < n; o++) { var c = a(e, t), u = a(e, t += r); t += r, 0 != o || s ? et.G.lineTo(l, c, u) : et.G.moveTo(l, c, u) } return i && et.G.closePath(l), t }, (tt.B = { uint8: new Uint8Array(4), readShort: function (e, t) { var n = tt.B.uint8; return n[0] = e[t], n[1] = e[t + 1], tt.B.int16[0] }, readUshort: function (e, t) { var n = tt.B.uint8; return n[0] = e[t], n[1] = e[t + 1], tt.B.uint16[0] }, readInt: function (e, t) { var n = tt.B.uint8; return n[0] = e[t], n[1] = e[t + 1], n[2] = e[t + 2], n[3] = e[t + 3], tt.B.int32[0] }, readUint: function (e, t) { var n = tt.B.uint8; return n[0] = e[t], n[1] = e[t + 1], n[2] = e[t + 2], n[3] = e[t + 3], tt.B.uint32[0] }, readFloat: function (e, t) { var n = tt.B.uint8; return n[0] = e[t], n[1] = e[t + 1], n[2] = e[t + 2], n[3] = e[t + 3], tt.B.flot32[0] }, readASCII: function (e, t, n) { for (var l = "", r = 0; r < n; r++)l += String.fromCharCode(e[t + r]); return l } }).int16 = new Int16Array(tt.B.uint8.buffer), tt.B.uint16 = new Uint16Array(tt.B.uint8.buffer), tt.B.int32 = new Int32Array(tt.B.uint8.buffer), tt.B.uint32 = new Uint32Array(tt.B.uint8.buffer), tt.B.flot32 = new Float32Array(tt.B.uint8.buffer), tt.C = { EMR_HEADER: 1, EMR_POLYBEZIER: 2, EMR_POLYGON: 3, EMR_POLYLINE: 4, EMR_POLYBEZIERTO: 5, EMR_POLYLINETO: 6, EMR_POLYPOLYLINE: 7, EMR_POLYPOLYGON: 8, EMR_SETWINDOWEXTEX: 9, EMR_SETWINDOWORGEX: 10, EMR_SETVIEWPORTEXTEX: 11, EMR_SETVIEWPORTORGEX: 12, EMR_SETBRUSHORGEX: 13, EMR_EOF: 14, EMR_SETPIXELV: 15, EMR_SETMAPPERFLAGS: 16, EMR_SETMAPMODE: 17, EMR_SETBKMODE: 18, EMR_SETPOLYFILLMODE: 19, EMR_SETROP2: 20, EMR_SETSTRETCHBLTMODE: 21, EMR_SETTEXTALIGN: 22, EMR_SETCOLORADJUSTMENT: 23, EMR_SETTEXTCOLOR: 24, EMR_SETBKCOLOR: 25, EMR_OFFSETCLIPRGN: 26, EMR_MOVETOEX: 27, EMR_SETMETARGN: 28, EMR_EXCLUDECLIPRECT: 29, EMR_INTERSECTCLIPRECT: 30, EMR_SCALEVIEWPORTEXTEX: 31, EMR_SCALEWINDOWEXTEX: 32, EMR_SAVEDC: 33, EMR_RESTOREDC: 34, EMR_SETWORLDTRANSFORM: 35, EMR_MODIFYWORLDTRANSFORM: 36, EMR_SELECTOBJECT: 37, EMR_CREATEPEN: 38, EMR_CREATEBRUSHINDIRECT: 39, EMR_DELETEOBJECT: 40, EMR_ANGLEARC: 41, EMR_ELLIPSE: 42, EMR_RECTANGLE: 43, EMR_ROUNDRECT: 44, EMR_ARC: 45, EMR_CHORD: 46, EMR_PIE: 47, EMR_SELECTPALETTE: 48, EMR_CREATEPALETTE: 49, EMR_SETPALETTEENTRIES: 50, EMR_RESIZEPALETTE: 51, EMR_REALIZEPALETTE: 52, EMR_EXTFLOODFILL: 53, EMR_LINETO: 54, EMR_ARCTO: 55, EMR_POLYDRAW: 56, EMR_SETARCDIRECTION: 57, EMR_SETMITERLIMIT: 58, EMR_BEGINPATH: 59, EMR_ENDPATH: 60, EMR_CLOSEFIGURE: 61, EMR_FILLPATH: 62, EMR_STROKEANDFILLPATH: 63, EMR_STROKEPATH: 64, EMR_FLATTENPATH: 65, EMR_WIDENPATH: 66, EMR_SELECTCLIPPATH: 67, EMR_ABORTPATH: 68, EMR_COMMENT: 70, EMR_FILLRGN: 71, EMR_FRAMERGN: 72, EMR_INVERTRGN: 73, EMR_PAINTRGN: 74, EMR_EXTSELECTCLIPRGN: 75, EMR_BITBLT: 76, EMR_STRETCHBLT: 77, EMR_MASKBLT: 78, EMR_PLGBLT: 79, EMR_SETDIBITSTODEVICE: 80, EMR_STRETCHDIBITS: 81, EMR_EXTCREATEFONTINDIRECTW: 82, EMR_EXTTEXTOUTA: 83, EMR_EXTTEXTOUTW: 84, EMR_POLYBEZIER16: 85, EMR_POLYGON16: 86, EMR_POLYLINE16: 87, EMR_POLYBEZIERTO16: 88, EMR_POLYLINETO16: 89, EMR_POLYPOLYLINE16: 90, EMR_POLYPOLYGON16: 91, EMR_POLYDRAW16: 92, EMR_CREATEMONOBRUSH: 93, EMR_CREATEDIBPATTERNBRUSHPT: 94, EMR_EXTCREATEPEN: 95, EMR_POLYTEXTOUTA: 96, EMR_POLYTEXTOUTW: 97, EMR_SETICMMODE: 98, EMR_CREATECOLORSPACE: 99, EMR_SETCOLORSPACE: 100, EMR_DELETECOLORSPACE: 101, EMR_GLSRECORD: 102, EMR_GLSBOUNDEDRECORD: 103, EMR_PIXELFORMAT: 104, EMR_DRAWESCAPE: 105, EMR_EXTESCAPE: 106, EMR_SMALLTEXTOUT: 108, EMR_FORCEUFIMAPPING: 109, EMR_NAMEDESCAPE: 110, EMR_COLORCORRECTPALETTE: 111, EMR_SETICMPROFILEA: 112, EMR_SETICMPROFILEW: 113, EMR_ALPHABLEND: 114, EMR_SETLAYOUT: 115, EMR_TRANSPARENTBLT: 116, EMR_GRADIENTFILL: 118, EMR_SETLINKEDUFIS: 119, EMR_SETTEXTJUSTIFICATION: 120, EMR_COLORMATCHTOTARGETW: 121, EMR_CREATECOLORSPACEW: 122 }, tt.K = []; let nt = function (e, t) { this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.bb = null, this.currPage = 0, this.needPage = e, this.scale = t }; nt.prototype.StartPage = function (e, t, n, l) { if (this.currPage == this.needPage) { this.bb = [e, t, n, l]; var r = this.scale, i = window.devicePixelRatio, s = this.canvas, a = this.ctx; s.width = Math.round(n * r), s.height = Math.round(l * r), a.translate(0, l * r), a.scale(r, -r), s.setAttribute("style", "border:1px solid; width:" + s.width / i + "px; height:" + s.height / i + "px") } }, nt.prototype.Fill = function (e, t) { if (this.currPage == this.needPage) { var n = this.ctx; n.beginPath(), this._setStyle(e, n), this._draw(e.pth, n), n.fill() } }, nt.prototype.Stroke = function (e) { if (this.currPage == this.needPage) { var t = this.ctx; t.beginPath(), this._setStyle(e, t), this._draw(e.pth, t), t.stroke() } }, nt.prototype.PutText = function (e, t, n) { if (this.currPage == this.needPage) { this._scale(e.ctm); var l = this.ctx; this._setStyle(e, l), l.save(); var r = [1, 0, 0, -1, 0, 0]; this._concat(r, e.font.Tm), this._concat(r, e.ctm), l.transform(r[0], r[1], r[2], r[3], r[4], r[5]), l.fillText(t, 0, 0), l.restore() } }, nt.prototype.PutImage = function (e, t, n, l, r) { if (this.currPage == this.needPage) { var i = this.ctx; if (t.length == n * l * 4) { if (t = t.slice(0), r && r.length == n * l * 4) for (var s = 0; s < t.length; s += 4)t[s + 3] = r[s + 1]; var a = document.createElement("canvas"), o = a.getContext("2d"); a.width = n, a.height = l; var c = o.createImageData(n, l); for (s = 0; s < t.length; s++)c.data[s] = t[s]; o.putImageData(c, 0, 0), i.save(); var u = [1, 0, 0, 1, 0, 0]; this._concat(u, [1 / n, 0, 0, -1 / l, 0, 1]), this._concat(u, e.ctm), i.transform(u[0], u[1], u[2], u[3], u[4], u[5]), i.drawImage(a, 0, 0), i.restore() } } }, nt.prototype.ShowPage = function () { this.currPage++ }, nt.prototype.Done = function () { }, nt.prototype._setStyle = function (e, t) { var n = this._scale(e.ctm); t.fillStyle = this._getFill(e.colr, e.ca, t), t.strokeStyle = this._getFill(e.COLR, e.CA, t), t.lineCap = ["butt", "round", "square"][e.lcap], t.lineJoin = ["miter", "round", "bevel"][e.ljoin], t.lineWidth = e.lwidth * n; for (var l, r = e.dash.slice(0), i = 0; i < r.length; i++)r[i] = (l = r[i] * n, "" + parseFloat(l.toFixed(2))); t.setLineDash(r), t.miterLimit = e.mlimit * n; var s = e.font.Tf, a = s.toLowerCase(), o = -1 != a.indexOf("bold") ? "bold " : "", c = -1 != a.indexOf("italic") || -1 != a.indexOf("oblique") ? "italic " : ""; t.font = o + c + e.font.Tfs + 'px "' + s + '"' }, nt.prototype._getFill = function (e, t, n) { if (null == e.typ) return this._colr(e, t); var l, r = e, i = r.crds, s = r.mat, a = this._scale(s); if ("lin" == r.typ) { var o = this._multPoint(s, i.slice(0, 2)), c = this._multPoint(s, i.slice(2)); l = n.createLinearGradient(o[0], o[1], c[0], c[1]) } else "rad" == r.typ && (o = this._multPoint(s, i.slice(0, 2)), c = this._multPoint(s, i.slice(3)), l = n.createRadialGradient(o[0], o[1], i[2] * a, c[0], c[1], i[5] * a)); for (var u = 0; u < r.grad.length; u++)l.addColorStop(r.grad[u][0], this._colr(r.grad[u][1], t)); return l }, nt.prototype._colr = function (e, t) { return "rgba(" + Math.round(255 * e[0]) + "," + Math.round(255 * e[1]) + "," + Math.round(255 * e[2]) + "," + t + ")" }, nt.prototype._scale = function (e) { return Math.sqrt(Math.abs(e[0] * e[3] - e[1] * e[2])) }, nt.prototype._concat = function (e, t) { var n = e[0], l = e[1], r = e[2], i = e[3], s = e[4], a = e[5]; e[0] = n * t[0] + l * t[2], e[1] = n * t[1] + l * t[3], e[2] = r * t[0] + i * t[2], e[3] = r * t[1] + i * t[3], e[4] = s * t[0] + a * t[2] + t[4], e[5] = s * t[1] + a * t[3] + t[5] }, nt.prototype._multPoint = function (e, t) { var n = t[0], l = t[1]; return [n * e[0] + l * e[2] + e[4], n * e[1] + l * e[3] + e[5]] }, nt.prototype._draw = function (e, t) { for (var n = 0, l = e.crds, r = 0; r < e.cmds.length; r++) { var i = e.cmds[r]; "M" == i ? (t.moveTo(l[n], l[n + 1]), n += 2) : "L" == i ? (t.lineTo(l[n], l[n + 1]), n += 2) : "C" == i ? (t.bezierCurveTo(l[n], l[n + 1], l[n + 2], l[n + 3], l[n + 4], l[n + 5]), n += 6) : "Q" == i ? (t.quadraticCurveTo(l[n], l[n + 1], l[n + 2], l[n + 3]), n += 4) : "Z" == i && t.closePath() } }; class lt { constructor(e) { if (null != e) { this.images = {}; for (let i in e) if (i.indexOf("xl/media/") > -1) { let s = i.split("."), a = s[s.length - 1].toLowerCase(); if (a in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1, emf: 1 }) if ("emf" == a) { var t, n, l = new nt(0, 1); for (var r in n = tt.K = [], t = tt.C) n[t[r]] = r.slice(4); tt.Parse(e[i], l), this.images[i] = l.canvas.toDataURL("image/png") } else this.images[i] = e[i] } } } getImageByName(e) { if (e in this.images) { let t = this.images[e]; return new rt(e, t) } return null } } class rt extends xe { constructor(e, t) { super(), this.src = t, this.id = W("image") } setDefault() { } } class it { constructor(e) { let t = e.getElementsByTagName("definedNames/definedName", v); const n = {}; t.forEach((e => { const t = new st(e); n[t.id] = t })), this.defineNames = n } } class st { constructor(e) { this.id = re(6), this.name = e.get("name"), this.formulaOrRefString = U(e.value), this.comment = e.get("comment"), this.localSheetId = e.get("localSheetId"), this.hidden = "1" === e.get("hidden") } } class at extends de { constructor(e, t) { super(), this.columnWidthSet = [], this.rowHeightSet = [], this.handleWorkBookInfo = () => { this.workbook = new me; const e = new it(this.readXml); e?.defineNames && (this.workbook.defineNames = e.defineNames) }, this.files = e, this.fileName = t, this.readXml = new ue(e), this.getSheetNameList(), this.sharedStrings = this.readXml.getElementsByTagName("sst/si", "xl/sharedStrings.xml"), this.calcChain = this.readXml.getElementsByTagName("calcChain/c", "xl/calcChain.xml"), this.styles = {}, this.styles.cellXfs = this.readXml.getElementsByTagName("cellXfs/xf", w), this.styles.cellStyleXfs = this.readXml.getElementsByTagName("cellStyleXfs/xf", w), this.styles.cellStyles = this.readXml.getElementsByTagName("cellStyles/cellStyle", w), this.styles.fonts = this.readXml.getElementsByTagName("fonts/font", w), this.styles.fills = this.readXml.getElementsByTagName("fills/fill", w), this.styles.borders = this.readXml.getElementsByTagName("borders/border", w), this.styles.clrScheme = this.readXml.getElementsByTagName("a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink", "xl/theme/theme1.xml"), this.styles.indexedColors = this.readXml.getElementsByTagName("colors/indexedColors/rgbColor", w), this.styles.mruColors = this.readXml.getElementsByTagName("colors/mruColors/color", w), this.styles.dxfs = this.readXml.getElementsByTagName("dxfs/dxf", w), this.imageList = new lt(e), this.cellImages = this.readXml.getElementsByTagName("etc:cellImages/etc:cellImage", "xl/cellimages.xml"); let n = this.readXml.getElementsByTagName("numFmt/numFmt", w), l = JSON.parse(JSON.stringify(I)); for (let e = 0; e < n.length; e++) { let t = n[e].attributeList, r = X(t, "numFmtId", "49"), i = X(t, "formatCode", "@"); r in I || (l[r] = L[i] || i) } this.styles.numfmts = l } getSheetNameList() { let e = this.readXml.getElementsByTagName("Relationships/Relationship", "xl/_rels/workbook.xml.rels"); if (null == e) return; let t = new RegExp("worksheets/[^/]*?.xml"), n = {}; for (let l = 0; l < e.length; l++) { let r = e[l].attributeList, i = r.Id, s = r.Target; t.test(s) && (0 === s.indexOf("/xl") ? n[i] = s.substr(1) : n[i] = "xl/" + s) } this.sheetNameList = n } getSheetFileBysheetId(e) { return this.sheetNameList[e] } getWorkBookInfo() { let e = this.readXml.getElementsByTagName("Company", y), t = this.readXml.getElementsByTagName("AppVersion", y), n = this.readXml.getElementsByTagName("dc:creator", T), l = this.readXml.getElementsByTagName("cp:lastModifiedBy", T), r = this.readXml.getElementsByTagName("dcterms:created", T), i = this.readXml.getElementsByTagName("dcterms:modified", T); this.info = new Ee, this.info.name = this.fileName, this.info.creator = n.length > 0 ? n[0].value : "", this.info.lastmodifiedby = l.length > 0 ? l[0].value : "", this.info.createdTime = r.length > 0 ? r[0].value : "", this.info.modifiedTime = i.length > 0 ? i[0].value : "", this.info.company = e.length > 0 ? e[0].value : "", this.info.appversion = t.length > 0 ? t[0].value : "" } getSheetsFull(e = !0) { let t = this.readXml.getElementsByTagName("sheets/sheet", v), n = {}; for (let e in t) { let l = t[e]; n[l.attributeList.name] = l.attributeList.sheetId } this.sheets = []; let l = 0; for (let r in t) { let i, s, a = t[r], o = a.attributeList.name, c = a.attributeList.sheetId, u = a.attributeList["r:id"], h = this.getSheetFileBysheetId(u), f = "hidden" === a.attributeList.state ? 1 : 0, g = this.readXml.getElementsByTagName("worksheet/drawing", h); if (null != g && g.length > 0) { let e = X(g[0].attributeList, "r:id", null); null != e && (i = this.getDrawingFile(e, h), s = this.getDrawingRelsFile(i)) } if (null != h) { let t = new Qe(o, c, l, e, { sheetFile: h, readXml: this.readXml, sheetList: n, styles: this.styles, sharedStrings: this.sharedStrings, calcChain: this.calcChain, imageList: this.imageList, drawingFile: i, drawingRelsFile: s, hide: f, cellImages: this.cellImages }); this.columnWidthSet = [], this.rowHeightSet = [], this.imagePositionCaculation(t), this.sheets.push(t), l++ } } } extendArray(e, t, n, l, r) { if (e < t.length) return; let i = t.length, s = e, a = 0; i > 0 && (a = t[i - 1]); for (let e = i; e <= s; e++) { let i = n, s = e.toString(); s in l ? i = 0 : s in r && (i = r[s]), a += Math.round(i + 1), t.push(a) } } imagePositionCaculation(e) { let t = e.images, n = e.defaultColWidth, l = e.defaultRowHeight, r = {}; e.config.colhidden && (r = e.config.colhidden); let i = {}; e.config.columnlen && (i = e.config.columnlen); let s = {}; e.config.rowhidden && (s = e.config.rowhidden); let a = {}; e.config.rowlen && (a = e.config.rowlen); for (let e in t) { let o = t[e], c = o.fromCol, u = o.fromColOff, h = o.fromRow, f = o.fromRowOff, g = o.toCol, d = o.toColOff, m = o.toRow, p = o.toRowOff, E = 0, b = 0, T = 0, y = 0; c >= this.columnWidthSet.length && this.extendArray(c, this.columnWidthSet, n, r, i), E = 0 == c ? 0 : this.columnWidthSet[c - 1], E += u, h >= this.rowHeightSet.length && this.extendArray(h, this.rowHeightSet, l, s, a), b = 0 == h ? 0 : this.rowHeightSet[h - 1], b += f, g >= this.columnWidthSet.length && this.extendArray(g, this.columnWidthSet, n, r, i), T = 0 == g ? 0 : this.columnWidthSet[g - 1], T = T + d - E, m >= this.rowHeightSet.length && this.extendArray(m, this.rowHeightSet, l, s, a), y = 0 == m ? 0 : this.rowHeightSet[m - 1], y = y + p - b, o.originWidth = T, o.originHeight = y, o.crop.height = y, o.crop.width = T, o.default.height = y, o.default.left = E, o.default.top = b, o.default.width = T } } getDrawingFile(e, t) { let n = t.split("/"), l = "xl/worksheets/_rels/" + n[n.length - 1] + ".rels", r = this.readXml.getElementsByTagName("Relationships/Relationship", l); if (r.length > 0) for (let t = 0; t < r.length; t++) { let n = r[t].attributeList; if (X(n, "Id", null) == e) { let e = X(n, "Target", null); if (null != e) return e.replace(/\.\.\//g, "") } } return null } getDrawingRelsFile(e) { let t = e.split("/"); return "xl/drawings/_rels/" + t[t.length - 1] + ".rels" } getSheetsWithoutCell() { this.getSheetsFull(!1) } Parse() { return this.getWorkBookInfo(), this.handleWorkBookInfo(), this.getSheetsFull(), this.toJsonString(this) } toJsonString(e) { let t = new de; return t.info = e.info, t.workbook = e.workbook, t.sheets = [], e.sheets.forEach((e => { let n = new pe; null != e.name && (n.name = e.name), null != e.color && (n.color = e.color), null != e.config && (n.config = e.config), null != e.index && (n.index = e.index), null != e.status && (n.status = e.status), null != e.order && (n.order = e.order), null != e.row && (n.row = e.row), null != e.column && (n.column = e.column), null != e.luckysheet_select_save && (n.luckysheet_select_save = e.luckysheet_select_save), null != e.scrollLeft && (n.scrollLeft = e.scrollLeft), null != e.scrollTop && (n.scrollTop = e.scrollTop), null != e.zoomRatio && (n.zoomRatio = e.zoomRatio), null != e.showGridLines && (n.showGridLines = e.showGridLines), null != e.defaultColWidth && (n.defaultColWidth = e.defaultColWidth), null != e.defaultRowHeight && (n.defaultRowHeight = e.defaultRowHeight), null != e.celldata && (n.celldata = [], e.celldata.forEach((e => { let t = new be; t.r = e.r, t.c = e.c, t.v = e.v, n.celldata.push(t) }))), null != e.chart && (n.chart = e.chart), null != e.isPivotTable && (n.isPivotTable = e.isPivotTable), null != e.pivotTable && (n.pivotTable = e.pivotTable), null != e.luckysheet_conditionformat_save && (n.luckysheet_conditionformat_save = e.luckysheet_conditionformat_save), null != e.freezen && (n.freezen = e.freezen), null != e.calcChain && (n.calcChain = e.calcChain), null != e.images && (n.images = e.images), null != e.charts && (n.charts = e.charts), null != e.dataVerification && (n.dataVerification = e.dataVerification), null != e.hyperlink && (n.hyperlink = e.hyperlink), null != e.hide && (n.hide = e.hide), null != e.conditionalFormatting && e.conditionalFormatting.length && (n.conditionalFormatting = e.conditionalFormatting), null != e.dataVerificationList && e.dataVerificationList.length && (n.dataVerificationList = e.dataVerificationList), null != e.filter && (n.filter = e.filter), t.sheets.push(n) })), JSON.stringify(t) } } class ot { constructor(e) { this.uploadFile = e } unzipFile(e, t) { (new r).loadAsync(this.uploadFile).then((function (t) { let n = {}, l = Object.keys(t.files).length, r = 0; t.forEach((function (t, i) { let s = i.name.split("."), a = s[s.length - 1].toLowerCase(), o = "string"; a in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1 } ? o = "base64" : "emf" == a && (o = "arraybuffer"), i.async(o).then((function (t) { "base64" == o && (t = "data:image/" + a + ";base64," + t), n[i.name] = t, l == r + 1 && e(n), r++ })) })) }), (function (e) { t(e) })) } unzipFileByUrl(e, t, n) { var l = new r; !function (e, t) { let n, l, r; t || (t = {}); let i = function () { try { return new window.XMLHttpRequest } catch (e) { } }; var s = "undefined" != typeof window && window.ActiveXObject ? function () { return i() || function () { try { return new window.ActiveXObject("Microsoft.XMLHTTP") } catch (e) { } }() } : i; "function" == typeof t ? (r = t, t = {}) : "function" == typeof t.callback && (r = t.callback), n = function (e) { r(null, e) }, l = function (e) { r(e, null) }; try { var a = s(); a.open("GET", e, !0), "responseType" in a && (a.responseType = "arraybuffer"), a.overrideMimeType && a.overrideMimeType("text/plain; charset=x-user-defined"), a.onreadystatechange = function (t) { if (4 === a.readyState) if (200 === a.status || 0 === a.status) try { n(function (e) { return e.response || e.responseText }(a)) } catch (e) { l(new Error(e)) } else l(new Error("Ajax error for " + e + " : " + this.status + " " + this.statusText)) }, t.progress && (a.onprogress = function (n) { t.progress({ path: e, originalEvent: n, percent: n.loaded / n.total * 100, loaded: n.loaded, total: n.total }) }), a.send() } catch (e) { l(new Error(e)) } }(e, (function (e, r) { if (e) throw e; l.loadAsync(r).then((function (e) { let n = {}, l = Object.keys(e.files).length, r = 0; e.forEach((function (e, i) { let s = i.name.split("."), a = s[s.length - 1].toLowerCase(), o = "string"; a in { png: 1, jpeg: 1, jpg: 1, gif: 1, bmp: 1, tif: 1, webp: 1 } ? o = "base64" : "emf" == a && (o = "arraybuffer"), i.async(o).then((function (e) { "base64" == o && (e = "data:image/" + a + ";base64," + e), n[i.name] = e, l == r + 1 && t(n), r++ })) })) }), (function (e) { n(e) })) })) } newZipFile() { var e = new r; this.workBook = e } addToZipFile(e, t) { if (null == this.workBook) { var n = new r; this.workBook = n } this.workBook.file(e, t) } } function ct(e, t = "") { if (!e) return e; const n = ut[e]; return n && (e = n), e.toLocaleUpperCase().replace("#", t) } const ut = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" }; function ht(e) { return e / 96 * 72 } function ft(e) { return (e - 10) / 8 + .83 + .64 } function gt(e, t) { if (void 0 !== e) return void 0 === t ? e : t } function dt(e = {}, t, n = !1) { return { numFmt: t, font: mt(e), alignment: Et(e), protection: null, border: pt(e.bd), fill: bt(e.bg?.rgb, n) } } function mt(e) { const t = { underline: { 10: "double", 12: "single" }, vertAlign: { 1: void 0, 2: "subscript", 3: "superscript" } }; return { name: e.ff, size: e.fs, family: 1, color: gt(e.cl?.rgb, { argb: ct(e.cl?.rgb) }), bold: gt(e.bl, 1 === e.bl), italic: gt(e.it, 1 === e.it), underline: gt(e.ul?.s, 1 === e.ul?.s && (t.underline[e.ul.t] || !0)), vertAlign: gt(e.va, t.vertAlign[e.va]), strike: gt(e.st?.s, 1 === e.st?.s), outline: gt(e.ol?.s, 1 === e.ol?.s), charset: 134 } } function pt(e) { if (!e) return null; const t = { 0: "none", 1: "thin", 2: "hair", 3: "dotted", 4: "dashDot", 5: "dashDot", 6: "dashDotDot", 7: "double", 8: "medium", 9: "mediumDashed", 10: "mediumDashDot", 11: "mediumDashDotDot", 12: "slantDashDot", 13: "thick" }, n = e => { if (e) return { style: t[e?.s || 1], color: { argb: ct(e?.cl?.rgb || "#d9d9d9") } } }, l = n(e.bl_tr || e.tl_br) || {}; return { top: n(e.t), right: n(e.r), bottom: n(e.b), left: n(e.l), diagonal: { up: !!e.bl_tr, down: !!e.tl_br, ...l } } } function Et(e) { const t = { horizontal: { 0: "left", 1: "left", 2: "center", 3: "right" }, vertical: { 1: "top", 2: "middle", 3: "bottom" }, wrapText: { 3: !0 } }; return { horizontal: gt(e.ht, t.horizontal[e.ht]), vertical: gt(e.vt, t.vertical[e.vt]), wrapText: gt(e.tb, 3 === e.tb), textRotation: gt(e.tr?.a) } } function bt(e, t = !1) { if (!e) return null; if (!e) return { type: "pattern", pattern: "none" }; const n = { type: "pattern", pattern: "solid" }; return t ? n.bgColor = { argb: ct(e, "FF") } : n.fgColor = { argb: ct(e, "FF") }, n } class Tt { constructor(e, t, n, l) { this.sheetId = e, this.workbook = t, this.worksheet = n, this.resources = l, this.setImages(), this.setConditional(), this.setDataValidation(), this.setFilter() } handleRang(e) { const { startRow: t, startColumn: n, endRow: l, endColumn: r } = e; return function (e) { let t = e.row[0], n = e.row[1], l = e.column[0], r = e.column[1]; return null == t && null == n ? ne(l) + ":" + ne(r) : null == l && null == r ? t + 1 + ":" + (n + 1) : l == r && t == n ? "" + ne(l) + (t + 1) : "" + ne(l) + (t + 1) + ":" + ne(r) + (n + 1) }({ row: [t, l], column: [n, r] }) } setFilter() { const e = this.getSheetResource("SHEET_FILTER_PLUGIN"); e && (this.worksheet.autoFilter = this.handleRang(e.ref)) } setConditional() { const e = this.getSheetResource("SHEET_CONDITIONAL_FORMATTING_PLUGIN"), t = []; e && (e.forEach((e => { const { ranges: n, rule: l, stopIfTrue: r } = e; n.forEach((n => { const l = this.handleRang(n), r = t.findIndex((e => e.ref === l)), i = this.handleRule(e); r > -1 ? t[r].rules.push(i) : t.push({ ref: l, rules: [i] }) })) })), t.forEach((e => { this.worksheet.addConditionalFormatting(e) }))) } setDataValidation() { const e = this.getSheetResource("SHEET_DATA_VALIDATION_PLUGIN"), t = (e, t = !1) => { const n = Math.round(24 * (e - 25569 + (t ? 1462 : 0)) * 3600 * 1e3); return new Date(n) }; e?.forEach((e => { const { ranges: n = [], type: l, allowBlank: r, operator: i, formula1: s, formula2: a, showErrorMessage: o, showInputMessage: c, prompt: u, promptTitle: h, error: f, errorTitle: g, errorStyle: d } = e || {}; let m = [s]; oe(a) || m.push(a), "list" === l && (m = [`"${s}"`], oe(a) || m.push(`"${a}"`)), "date" === l && (m = [t(s)], oe(a) || m.push(t(a))); const p = n.map((e => this.handleRang(e))), E = { type: l, allowBlank: r, operator: i, formulae: m, showErrorMessage: o, showInputMessage: c, prompt: u, promptTitle: h, error: f, errorTitle: g, errorStyle: ["information", "stop", "warning"][d] }; p.forEach((e => { this.worksheet.dataValidations.add(e, ae(E)) })) })) } setImages() { const e = this.getSheetResource("SHEET_DRAWING_PLUGIN"), t = e?.data; if (t) for (const e in t) { const n = t[e]; let l = this.workbook.getImages().findIndex((e => "png" === e.extension && e.base64 === n.source)); -1 === l && (l = this.workbook.addImage({ base64: n.source, extension: "png" })); const r = e => ({ nativeCol: e.column, nativeColOff: D(e.columnOffset), nativeRow: e.row, nativeRowOff: D(e.rowOffset) }); this.worksheet.addImage(l, { tl: r(n.sheetTransform.from), br: r(n.sheetTransform.to) }) } } getSheetResource(e) { return ie(this.resources.find((t => t.name === e))?.data)[this.sheetId] } handleRule(e) { const { rule: t, stopIfTrue: n, order: l } = e, r = {}; switch (n && (r.stopIfTrue = 1), r.priority = l, t.style && (r.style = dt(t.style, t.style.n?.pattern, !0)), t.operator && (r.operator = t.operator), t.type) { case We.colorScale: r.type = We.colorScale, r.cfvo = t.config?.map((e => ({ type: e.value.type, value: e.value.value }))), r.color = t.config?.map((e => ({ argb: ct(e.color) }))); break; case We.dataBar: r.type = We.dataBar, r.showValue = t.isShowValue, r.gradient = t.config.isGradient, r.cfvo = [{ type: t.config.min.type, value: t.config.min.value }, { type: t.config.max.type, value: t.config.max.value }], r.negativeFillColor = { argb: ct(t.config.nativeColor) }, r.color = { argb: ct(t.config.positiveColor) }, r.axisPosition = "auto", r.direction = "leftToRight", r.minLength = 0, r.maxLength = 100, r.negativeBarColorSameAsPositive = !0, r.negativeBarBorderColorSameAsPositive = !0; break; case We.iconSet: r.type = We.iconSet, r.reverse = !1, r.showValue = t.isShowValue, r.icons = t.config?.map((e => ({ iconId: le(e.iconType.charAt(0)) - le(e?.iconId) - 1, iconSet: e.iconType }))).reverse(), r.custom = !0, r.cfvo = t.config?.map((e => ({ type: e.value.type, value: e.value.value }))).reverse(); break; case We.highlightCell: switch (t.subType) { case Ue.average: r.type = "aboveAverage", r.aboveAverage = !1; break; case Ue.duplicateValues: r.type = "duplicateValues"; break; case Ue.formula: r.type = "expression", r.formulae = [U(t.value)]; break; case Ue.number: r.type = "cellIs", r.formulae = [t.value]; break; case Ue.rank: r.type = "top10", r.rank = t.value, r.percent = t.isPercent, r.bottom = t.isBottom; break; case Ue.text: r.type = "containsText", r.text = t.value; break; case Ue.timePeriod: r.type = "timePeriod", r.timePeriod = t.operator } }return r } } class yt { } class vt { } function wt(e, t, n) { const { sheets: l } = t, r = function (e) { const { resources: t, sheetId: n, rowId: l, columnId: r } = e, i = ie(t.find((e => "SHEET_HYPER_LINK_PLUGIN" === e.name))?.data); return (i?.[n] || []).find((e => e.row === Number(l) && e.column === Number(r))) }(t), i = function (e, t) { let n; if (e) { const { payload: l } = e; let r = "", i = ""; if (l.includes("#gid=") || l.includes("range=")) { const e = l.replace("#", "").split("&"); r += "", 1 === e.length && e[0].includes("range=") && (r += e[0].replace("range=")), 2 === e.length && (r += `'${function (e, t) { return e[t]?.name }(t, e[0].replace("gid=", ""))}'`, r += `!${e[1].replace("range=", "")}`) } else r = l, i = "External"; r && (n = { hyperlink: r, hyperlinkModel: i }) } return n }(r, l); let s; if (e.p) { const t = e.p?.body; if (e.p.drawingsOrder?.length) { const t = e.p.drawings[e.p.drawingsOrder[0]], { id: l, value: r } = n.addCellImage({ base64: t.source, extension: "png", descr: t.description, ext: { width: t.transform.width, height: t.transform.height } }); return s = { id: l, cellImageId: r, ...i || {} }, s } s = { richText: t?.textRuns.map((e => ({ text: t.dataStream.substring(e.st, e.ed), font: mt(e.ts) }))) } } else s = e.si ? { formula: e.si, result: e.v } : e.v; if (i) { const e = s?.richText?.map?.((e => e.text))?.join("") || s?.result || s; s = { text: e, ...i } } return s } const It = i.Workbook; class Rt extends It { constructor(e) { super(), this.init(e) } init(e) { this.calcProperties.fullCalcOnLoad = !0, this.setDefineNames(e.resources), function (e, t) { const { sheetOrder: n, sheets: l, styles: r, resources: i } = t; n.forEach((n => { const s = l[n], { id: a, name: o, tabColor: c, defaultRowHeight: u, defaultColumnWidth: h, hidden: f, rightToLeft: g, showGridlines: d, freeze: m, mergeData: p } = s, E = new yt; E.rightToLeft = 1 === g, E.showGridLines = 1 === d; const b = new vt; (m.xSplit > 0 || m.ySplit > 0) && (b.state = "frozen", b.xSplit = m.xSplit, b.ySplit = m.ySplit); const T = Object.assign(E, b), y = ft(h), v = ht(u), w = e.addWorksheet(o, { views: [T], state: 1 === f ? "hidden" : "visible", properties: { tabColor: c ? { argb: ct(c) } : void 0, defaultColWidth: y, defaultRowHeight: v, dyDescent: 0 } }); !function (e, t = {}, n) { for (const l in t) if (Object.prototype.hasOwnProperty.call(t, l)) { const r = t[l], i = e.getColumn(Number(l) + 1); i.width = r.w ? ft(r.w) : n, i.hidden = 1 === r.hd } }(w, s.columnData, y), function (e, t = {}, n) { for (const l in t) if (Object.prototype.hasOwnProperty.call(t, l)) { const r = t[l], i = e.getRow(Number(l) + 1); i.height = r.h ? ht(r.h) : n, i.hidden = 1 === r.hd } }(w, s.rowData, v), function (e, t, n, l, r) { const { resources: i, sheets: s } = l, { cellData: a, id: o } = t; for (const t in a) { const l = a[t]; for (const a in l) { const c = l[a]; if (!c) continue; const u = e.getCell(Number(t) + 1, Number(a) + 1); u.value = wt(c, { resources: i, sheetId: o, rowId: t, columnId: a, sheets: s }, r); let h = c.s; "string" == typeof c.s && (h = n[c.s]); const f = ae(dt(h, h?.n?.pattern || c.f)); Object.assign(u, f) } } }(w, s, r, t, e), function (e, t) { t.forEach((t => { e.mergeCells(t.startRow + 1, t.startColumn + 1, t.endRow + 1, t.endColumn + 1) })) }(w, p), new Tt(a, e, w, i) })) }(this, e) } setDefineNames(e) { const t = ie(e.find((e => "SHEET_DEFINED_NAME_PLUGIN" === e.name))?.data); for (const e in t) { const n = t[e]; this.definedNames.add(n.formulaOrRefString, n.name) } } } class Ct { constructor(e) { this.csvList = {}, this.csvContent = {}, this.init(e) } init(e) { if (!e) return; const { sheetOrder: t, sheets: n } = e, l = {}; t.forEach((e => { const t = n[e]; if (!t) return; const { cellData: r, name: i } = t, s = []; for (const e in r) { const t = r[e]; for (const e in t) { const n = Number(e), l = Number(e); s[n] || (s[n] = []), s[n][l] = t[e]?.v } } l[i] = s })), this.csvList = l, this.handleCsvContent() } handleCsvContent() { const e = {}; for (const t in this.csvList) { const n = this.csvList[t]; let l = "data:text/csv;charset=utf-8,"; n.forEach((e => { l += e.join(",") + "\r\n" })), e[t] = l } this.csvContent = e } } class Lt { constructor(e) { this.type = s.GRID, this.tabColor = "", this.hidden = 0, this.freeze = { xSplit: 0, ySplit: 0, startRow: -1, startColumn: -1 }, this.rowCount = 100, this.columnCount = 20, this.zoomRatio = 1, this.scrollTop = 0, this.scrollLeft = 0, this.defaultColumnWidth = 93, this.defaultRowHeight = 27, this.mergeData = [], this.cellData = {}, this.rowData = {}, this.columnData = {}, this.rowHeader = { width: 46, hidden: 0 }, this.columnHeader = { height: 20, hidden: 0 }, this.showGridlines = 1, this.rightToLeft = 0, this.selections = []; const { id: t, name: n, cellData: l, rowCount: r = 0, colCount: i = 0 } = e || {}; this.id = t || "", this.name = n || "", this.cellData = l || {}, this.rowCount = Math.max(this.rowCount, r), this.columnCount = Math.max(this.columnCount, i) } } function St(e) { for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? delete e[t] : se(e[t]) && null !== e[t] && St(e[t])); return e } const xt = (e, t, n = !1) => { const { v: l } = e; if ("string" == typeof l || null == l) return; const r = { 0: a.MIDDLE, 1: a.TOP, 2: a.BOTTOM }; let i; if (t?.value && !n) { const e = e => e ? { s: e.style, cl: { rgb: e.color, th: h.DARK1 } } : null; i = { t: e(t.value?.t), r: e(t.value?.r), b: e(t.value?.b), l: e(t.value?.l), bl_tr: e(t.value?.bl_tr), tl_br: e(t.value?.tl_br) } } const s = { 0: o.CLIP, 1: o.OVERFLOW, 2: o.WRAP }; let g; l.tr && (g = { 1: 45, 2: 135, 3: 255, 4: 90, 5: 180 }[l.tr]), l.rt && (g = l.rt); const d = { 0: c.DASH, 1: c.SINGLE, 2: c.DOUBLE, 3: c.SINGLE, 4: c.DOUBLE }, m = { 0: u.CENTER, 1: u.LEFT, 2: u.RIGHT }; return { bd: i, bg: void 0 !== l.bg ? { rgb: l.bg, th: h.DARK1 } : void 0, bl: l.bl, cl: void 0 !== l.fc ? { rgb: l.fc, th: h.DARK1 } : void 0, ff: l.ff, fs: l.fs, ht: void 0 !== l.ht ? m[l.ht] : void 0, it: l.it, n: void 0 !== l.ct?.fa ? { pattern: l.ct.fa } : void 0, st: void 0 !== l.cl ? { s: 1 === l.cl ? f.TRUE : f.FALSE } : void 0, tb: void 0 !== l.tb ? s[l.tb] : void 0, tr: void 0 !== g ? { a: g, v: l.tr || l.rt ? f.TRUE : f.FALSE } : void 0, ul: void 0 !== l.un ? { s: void 0 === l.un ? f.FALSE : f.TRUE, t: l.un ? d[l.un] : c.DASH } : void 0, vt: void 0 !== l.vt ? r[l.vt] : void 0 } }; var Nt; !function (e) { e.URL = "URL", e.UUID = "UUID", e.BASE64 = "BASE64" }(Nt || (Nt = {})); class Ot extends Lt { constructor(e) { super(), this.hyperLink = [], this.handleMerge = e => { const t = e.merge; return t ? Object.values(t).map((e => ({ startRow: e.r, endRow: e.r + e.rs - 1, startColumn: e.c, endColumn: e.c + e.cs - 1 }))) : [] }, this.handleCellData = (e, t) => { const n = e => { const { v: n } = e; if ("string" == typeof n || null == n) return { v: n }; const l = { s: m.STRING, n: m.NUMBER, b: m.BOOLEAN, str: m.STRING }, r = t.borderInfo?.find((t => t.value.col_index === e.c && t.value.row_index === e.r)); let i = n.ct?.t && l[n.ct?.t] ? l[n.ct?.t] : m.NUMBER, s = i === m.NUMBER ? le(n.v) : n.v; i === m.BOOLEAN && (s = "1" == n.v ? 1 : 0), Number.isNaN(Number(s)) && i === m.NUMBER && (i = m.STRING), this.hyperLink.findIndex((t => t.column === e.c && t.row === e.r)) > -1 && (i = m.STRING); const a = n.f?.replace(/=_xlfn./g, "="), o = { f: a, s: xt(e, r), t: i, v: s }, c = this.handleDocument(e, t); c && (o.p = c); const u = this.handleCellImage(e, t); return u && (o.p = u, o.f = void 0, o.v = void 0), St(o) }; let l, r = 0; const i = e.reduce(((e, t) => (l === t.r ? e[t.r].push(t) : (l = t.r, e[l] = [t]), t.c > r && (r = t.c), e)), []), s = {}; return i.forEach(((e, t) => { for (let l = 0; l < r + 1; l++) { const r = e.find((e => e.c === l)) || { r: t, c: l, v: null }; s[r.r] || (s[r.r] = {}), s[r.r][r.c] = n(r) } })), { cellData: s, rowCount: i.length, colCount: r } }, this.handleDocument = (e, t) => { const n = (e, t) => { const n = new RegExp(t, "g"); let l; const r = []; for (; l = n.exec(e);)r.push(l.index); return r }; let l = null; const { v: r } = e; if ("string" != typeof r && null != r) { if (r.ct && "inlineStr" === r.ct.t) { r.ct.s = r.ct.s?.map((e => (e.v = (e => { const t = new RegExp("\r\n", "g"); return e.replace(t, "\r") })(e.v || ""), e))) || []; let i = r.ct.s.reduce(((e, t) => e + t.v), ""); i = i ? i.replace(/\n/g, "\r") + "\r\n" : ""; const s = { r: "\r", n: "\n", v: "\v", f: "\f", 0: "\0", t: "\t", b: "\b", x1A: "\x1a", x1B: "\x1b", x1C: "\x1c", x1D: "\x1d", x1E: "\x1e", x1F: "\x1f" }, a = n(i, s.r).map((e => ({ startIndex: e }))), o = n(i, s.n).map((e => ({ startIndex: e }))), c = r.ct.s.map(((n, l) => { const i = r.ct.s.reduce(((e, t, n) => n < l ? e + (t.v?.length || 0) : e), 0), s = i + (r.ct.s?.[l]?.v?.length || 0), a = t.borderInfo?.find((t => t.value.col_index === e.c && t.value.row_index === e.r)); return { st: i, ed: s, ts: xt({ v: r.ct.s[l] || r.ct.s[0], r: e.r, c: e.c }, a, !0) } })); l = { id: re(6), documentStyle: { documentFlavor: 0, pageSize: { width: 0, height: 0 }, renderConfig: {}, textStyle: {} }, body: { dataStream: i, paragraphs: a, sectionBreaks: o, textRuns: c }, drawings: {} } } return l } }, this.handleCellImage = (e, t) => { let n = null; const { v: l } = e; if ("string" != typeof l && null != l) { if (l.ct && "str" === l.ct.t && l.ct.ci) { const r = re(6), i = re(6), { default: s, src: a, descr: o } = l.ct.ci || {}, c = t.borderInfo?.find((t => t.value.col_index === e.c && t.value.row_index === e.r)); n = { id: i, documentStyle: { documentFlavor: 0, pageSize: { width: 0, height: 0 }, renderConfig: {}, textStyle: {} }, body: { dataStream: "\b\r\n", paragraphs: [{ startIndex: 1, paragraphStyle: { horizontalAlign: l.ht } }], sectionBreaks: [{ startIndex: 2 }], textRuns: [{ ed: 1, st: 0, ts: xt({ v: l, r: e.r, c: e.c }, c, !0) }], customBlocks: [{ startIndex: 0, blockId: r }] }, drawings: { [r]: { unitId: i, subUnitId: i, drawingId: r, layoutType: g.INLINE, title: "", description: o, docTransform: { size: { width: s.width, height: s.height }, positionH: { relativeFrom: 0, posOffset: 0 }, positionV: { relativeFrom: 1, posOffset: 0 }, angle: 0 }, drawingType: d.DRAWING_IMAGE, imageSourceType: Nt.BASE64, source: a, transform: s } }, drawingsOrder: [r] } } return n } }, this.handleRowAndColumnData = e => { const t = {}, n = {}; for (let t = 0; t < this.rowCount; t++)n[t] = { h: e.rowlen?.[t] || this.defaultRowHeight, ia: e.rowlen?.[t] ? f.FALSE : f.TRUE, ah: this.defaultRowHeight, hd: 0 === e.rowhidden?.[t] ? f.TRUE : f.FALSE }; for (let n = 0; n < this.columnCount; n++)t[n] = { w: e.columnlen?.[n] || this.defaultColumnWidth, hd: 0 === e.colhidden?.[n] ? f.TRUE : f.FALSE }; this.rowData = n, this.columnData = t }, this.handleSheetLink = e => { if (!e) return; const t = Object.keys(e).map((t => { const n = t.split("_")[0], l = t.split("_")[1], r = e[t]; let i = r.linkAddress; if ("internal" === r.linkType) { const e = r.linkAddress.split("!"); i = {}, e[0] && (i.gid = e[0]), e[1] && (i.range = e[1]) } return { id: re(6), row: Number(n), column: Number(l), payload: i } })); this.hyperLink = t }, this.handleFreeze = e => { this.freeze = { xSplit: e.vertical, ySplit: e.horizen, startColumn: e.vertical, startRow: e.horizen } }; const { color: t, zoomRatio: n, celldata: l, config: r = {}, showGridLines: i, defaultColWidth: s, defaultRowHeight: a, hide: o } = e || {}; if (this.name = e.name, this.id = `sheet-${e.index}`, e) { if (this.tabColor = t, this.zoomRatio = n, this.showGridlines = Number(i), this.defaultColumnWidth = s, this.defaultRowHeight = a, this.hidden = o, this.handleSheetLink(e.hyperlink), r.merge && (this.mergeData = this.handleMerge(r)), l?.length) { const { cellData: e, rowCount: t, colCount: n } = this.handleCellData(l, r); this.cellData = e, this.rowCount = this.rowCount > t ? this.rowCount : t + 1, this.columnCount = this.columnCount > n ? this.columnCount : n + 1 } this.handleRowAndColumnData(r), e.freezen && this.handleFreeze(e.freezen) } } get mode() { return { id: this.id, name: this.name, type: this.type, tabColor: this.tabColor, hidden: this.hidden, freeze: this.freeze, rowCount: this.rowCount, columnCount: this.columnCount, zoomRatio: this.zoomRatio, scrollTop: this.scrollTop, scrollLeft: this.scrollLeft, defaultColumnWidth: this.defaultColumnWidth, defaultRowHeight: this.defaultRowHeight, mergeData: this.mergeData, cellData: this.cellData, rowData: this.rowData, columnData: this.columnData, rowHeader: this.rowHeader, columnHeader: this.columnHeader, showGridlines: this.showGridlines, rightToLeft: this.rightToLeft, selections: this.selections, hyperLink: this.hyperLink } } } class Mt { constructor(e) { this.resources = [], this.handleHyperLinks = e => { const t = {}; for (const n in e) { const l = e[n].hyperLink; l?.length && (t[n] = l.map((t => { let n = t.payload; if ("string" != typeof t.payload) { n = "#"; const l = t.payload.gid.replace(/'|"/g, ""), r = Object.values(e).find((e => e.name === l))?.id; l && r && (n += `gid=${r}`), l && r && t.payload.range && (n += "&"), t.payload.range && (n += `range=${t.payload.range}`) } return { ...t, payload: n } }))) } this.resources?.push({ name: "SHEET_HYPER_LINK_PLUGIN", data: JSON.stringify(t) }) }, this.handleImage = (e, t) => { const n = {}; Object.values(e).forEach((e => { const l = t.find((t => t.name === e.name))?.images; if (!l) return; const r = Object.keys(l), i = {}; r.forEach((t => { const n = l[t]; e.columnCount < n.toCol && (e.columnCount = n.toCol + 1), e.rowCount < n.toRow && (e.rowCount = n.toRow + 1); let r = { unitId: this.id, subUnitId: e.id || "", drawingId: t, transform: { width: 0, height: 0, scaleX: 0, scaleY: 0, left: 0, top: 0, angle: 0, skewX: 0, skewY: 0, flipX: !1, flipY: !1, ...n.transform || {} }, sheetTransform: { angle: 0, skewX: 0, skewY: 0, flipX: !1, flipY: !1, from: { column: n.fromCol, columnOffset: n.fromColOff, row: n.fromRow, rowOffset: n.fromRowOff }, to: { column: n.toCol, columnOffset: n.toColOff, row: n.toRow, rowOffset: n.toRowOff } } }; r = "chart" === n.type ? { ...r, drawingType: d.DRAWING_CHART, componentKey: "Chart", data: { ...n.data || {}, range: `${e.name}!${n.data.range}` }, allowTransform: !0 } : { ...r, drawingType: d.DRAWING_IMAGE, imageSourceType: Nt.BASE64, source: n.src, prstGeom: "rect", anchorType: "1" }, i[t] = r })), n[e.id] = { data: i, order: r } })), this.resources?.push({ name: "SHEET_DRAWING_PLUGIN", data: JSON.stringify(n) }) }, this.handleChart = (e, t) => { const n = {}; Object.values(e).forEach((e => { const l = t.find((t => t.name === e.name))?.charts; l && l.forEach((t => { n[e.id] || (n[e.id] = []), n[e.id].push({ rangeInfo: { isRowDirection: t.isRowDirection, rangeInfo: { unitId: this.id, subUnitId: e.id || "", range: ke(t.range)[0] } }, id: t.id, chartType: t.chartType, context: t.context, style: t.style, dataAggregation: {} }) })) })), this.resources?.push({ name: "SHEET_CHART_PLUGIN", data: JSON.stringify(n) }) }, this.handleNames = e => { this.resources?.push({ name: "SHEET_DEFINED_NAME_PLUGIN", data: JSON.stringify(e.defineNames) }) }, this.handleCondition = e => { const t = {}; Object.keys(e).forEach((n => { const l = e[n].conditionalFormatting?.map((e => (e.rule?.style && (e.rule.style = xt({ v: e.rule.style, r: 0, c: 0 }, { value: e.rule?.style?.border, rangeType: "" })), e))); t[n] = l })), this.resources?.push({ name: "SHEET_CONDITIONAL_FORMATTING_PLUGIN", data: JSON.stringify(t) }) }, this.handleVerification = e => { const t = {}; Object.keys(e).forEach((n => { t[n] = e[n].dataVerificationList })), this.resources?.push({ name: "SHEET_DATA_VALIDATION_PLUGIN", data: JSON.stringify(t) }) }, this.handleFilter = e => { const t = {}; Object.keys(e).forEach((n => { t[n] = e[n].filter })), this.resources?.push({ name: "SHEET_FILTER_PLUGIN", data: JSON.stringify(t) }) }; const { info: t, sheets: n, workbook: l } = e; this.id = re(6), this.name = t.name, this.appVersion = t.appversion, this.locale = p.ZH_CN; const r = {}, i = [], s = {}; n.sort(((e, t) => Number(e.order) - Number(t.order))).forEach((e => { const t = new Ot(e); r[t.id] = t.mode, s[t.id] = e, i.push(t.id) })), this.handleHyperLinks(r), this.handleImage(r, n), this.handleChart(r, n), this.handleNames(l), this.handleCondition(s), this.handleVerification(s), this.handleFilter(s), this.sheetOrder = i, this.sheets = r } get mode() { return { id: this.id, rev: this.rev, name: this.name, appVersion: this.appVersion, locale: this.locale, styles: this.styles, sheetOrder: this.sheetOrder, sheets: this.sheets, resources: this.resources } } } class Ft { constructor(e) { const t = {}; let n = 0, l = 0; e.forEach(((e, r) => { r + 1 > n && (n = r + 1), e.forEach(((e, n) => { n + 1 > l && (l = n + 1), t[r] || (t[r] = {}), t[r][n] = { v: e || "" } })) })); const r = "sheet1", i = new Lt({ id: r, name: r, cellData: t, rowCount: n, colCount: l }); this.sheets = { [r]: i }, this.sheetOrder = [r], this.id = re(6), this.name = this.id } get mode() { return { id: this.id, rev: this.rev, name: this.name, appVersion: this.appVersion, locale: this.locale, styles: this.styles, sheetOrder: this.sheetOrder, sheets: this.sheets, resources: this.resources } } } class At { constructor() { } static transformExcelToLucky(e, t, n) { new ot(e).unzipFile((function (n) { let l = new at(n, e.name).Parse(), r = JSON.parse(l); null != t && t(r, l) }), (function (e) { n && n(e) })) } static transformExcelToLuckyByUrl(e, t, n, l) { (new ot).unzipFileByUrl(e, (function (e) { let l = new at(e, t).Parse(), r = JSON.parse(l); null != n && n(r, l) }), (function (e) { l && l(e) })) } static transformExcelToUniver(e, t, n) { new ot(e).unzipFile((function (n) { let l = new at(n, e.name).Parse(), r = JSON.parse(l); if (null != t) { const e = new Mt(r); t(e.mode, l) } }), (function (e) { n && n(e) })) } static transformCsvToUniver(e, t, l) { try { (({ file: e, charset: t = Be.UTF8 }) => new Promise(((n, l) => { e instanceof File || n(""); const r = new FileReader; r.onload = e => { try { const { result: t } = e.target; n(t) } catch (e) { l(e) } }, r.readAsText(e, t) })))({ file: e }).then((l => { const r = ((e, t) => { const l = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n"); let r = []; if (t.name.endsWith(".csv") || "text/csv" === t.type) r = n.parse(e, { delimiter: ",", skipEmptyLines: !0 }).data; else for (let e = 0; e < l.length; e++) { const t = l[e].replace(/\r/, ""); t && r.push(t.split(",")) } return r })(l, e), i = new Ft(r || []); t?.(i.mode, r) })) } catch (e) { l(e) } } static async transformUniverToExcel(e) { const { snapshot: t, fileName: n = `excel_${(new Date).getTime()}.xlsx`, getBuffer: l = !1, success: r, error: i } = e; try { const e = new Rt(t), i = await e.xlsx.writeBuffer(); l ? r?.(i) : (this.downloadFile(n, i), r?.()) } catch (e) { i?.(e) } } static async transformUniverToCsv(e) { const { snapshot: t, fileName: n = `csv_${(new Date).getTime()}.csv`, getBuffer: l = !1, success: r, error: i, sheetName: s } = e; try { const e = new Ct(t); let i; if (i = s ? e.csvContent[s] : e.csvContent, l) r?.(i); else { if (se(i)) { for (const e in i) if (Object.prototype.hasOwnProperty.call(i, e)) { const t = i[e]; this.downloadFile(`${n}_${e}`, t) } } else this.downloadFile(n, i); r?.() } } catch (e) { i(e) } } static downloadFile(e, t) { const n = document.createElement("a"); let l; l = "string" == typeof t ? new Blob([t], { type: "text/csv;charset=utf-8;" }) : new Blob([t], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8" }); const r = URL.createObjectURL(l); n.href = r, n.download = e, document.body.appendChild(n), n.click(), n.addEventListener("click", (() => { n.remove(), setTimeout((() => { URL.revokeObjectURL(r) }), 200) })) } } export { At as default };
